/////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const  
//Это глобальная таблица, где ключом будет состояние игры (system) ,
//а значением — уже рассчитанная оценка или информация о ходах
transpositionTable = new Map(),

// Веса фигур: 
// безусловные (для Ωfull и для getRank)
// и в разных ситуациях, на разнех клетках (тольоко для getRank)
C          = [],
C_helm     =   6,
C_helm_red =  10,
C_sword    =  50,
C_sword_castling = C_sword + 5,
C_axe     = 21,
C_axe_castling = C_axe + 5,
C_axe_red   = C_axe - 13,
C_axe_blue  = C_axe,
C_axe_green = C_axe - 6,
C_pike    = 15,
C_pike_castling = C_pike*2 + 5,
C_pike_red = C_pike,
C_pike_blue = C_pike - 6,
C_dart    = 12,
C_arrow   =  3;
C_arrow_red  =  C_arrow + 5,
C_arrow_ordinary  =  C_arrow + 1,
    
noType       = 'no',
redType      = 'red',  
blueType     = 'blue', 
greenType    = 'green',
    
// Бонусы мобильности фигур по клеткам (тольок для Ωfull)
MOBILITY_BONUS = {
    helm:   { red: 2, blue: 1, green: 1 }, // Король
    sword:  { red: 3, blue: 2, green: 1 }, // Ферзь
    axe:    { red: 2, blue: 3, green: 1 }, // Ладья
    pike:   { red: 2, blue: 1, green: 0 }, // Слон
    dart:   { red: 0, blue: 0, green: 2 }, // Конь
    arrow:  { red: 3, blue: 1, green: 1 }  // Пешка
},
    
// Offset-ы в system 
FIELD_UNIT = 0,      // 93 элемента: 0–92     id фигуры на этой клетке
UNIT_FIELD = 93,     // 53 элемента: 93–145   наоборот: id клетки этой фигуры
UNIT_PREV = 146,     // 53 элемента: 146–198  предыдущая клетка этой фигуры
UNIT_SIDE = 199,     // 53 элемента: 199–251  сторона этой фигуры: тёмные = 2, или светлые = 1
UNIT_SORT = 252,     // 53 элемента: 252–304  сорт этой фигуры: Король, Arhpm? Ладья, Слон, Конь или пешка                    
UNIT_CASTLING = 305, // 53 элемента: 305–357  сколько осталось рокировок у этой фигуры с Королём
QUEUE = 358,         // 1 элемент             очередь хода конкретно в этой системе
MOVE = 359;          // 1 элемент             номер хода конкретно в этой системе
    
const nUnits  = 52;
const nFields = (32 - 2)*3 + 2;
    
for (i = 1; i <= nUnits; i++) {
    if (i === 1) {
        C[i] = C_helm;  // Король
    }
    if (i === 2) {
        C[i] = C_sword; // Ферзь
    }
    if (i >= 3 && i <= 6) { // Ладья
        C[i] = C_axe;
    }
    if (i >= 7 && i <= 11) { // Конь
        C[i] = C_dart;
    }
    if (i >= 12 && i <= 16) { // Слон
        C[i] = C_pike;
    }
    if (i >= 17 && i <= 26) { // Пешка
        C[i] = C_arrow;
    }
    if (i === 27) {
        C[i] = C_helm;  // Король
    }
    if (i === 28) {
        C[i] = C_sword; // Ферзь
    }
    if (i >= 29 && i <= 32) { // Ладья
        C[i] = C_axe;
    }
    if (i >= 33 && i <= 37) { // Конь
        C[i] = C_dart;
    }
    if (i >= 38 && i <= 42) { // Слон
        C[i] = C_pike;
    }
    if (i >= 43 && i <= 52) { // Пешка
        C[i] = C_arrow;
    }
}

let branchCounter; // возможно не нужен, потому что отсекаюся все кроме одной ветки

// Распределение ценностей по id фигур
function getSortSymbol(sortValue) {
    if (sortValue === C_helm)  return helm;
    if (sortValue === C_sword) return sword;
    if (sortValue === C_axe)   return axe;
    if (sortValue === C_pike)  return pike;
    if (sortValue === C_dart)  return dart;
    if (sortValue === C_arrow) return arrow;
    return "неизвестно";
}

// Соответствие цвета и id клетки 
function colorType(u) {
           if (u === 0) {
        return noType;        // Икосаэдр и Додекаэдр — образуют ДВОЙСТВЕННУЮ ПАРУ
    } else if (u >=  1 && u <= 12) { // Красные пятиугольные клетки вершинах икосаэдра или в центрах граней додекаэдра, "обратномго" додекаэдру
        return redType;  
    } else if (u >= 13 && u <= 32) { // Синие шестиугольные клетки вершинах додекаэдра или в центрах граней икосаэдра , "обратномго" икосаэдру
        return blueType;
    } else if (u >= 33 && u <= 92) { // Зелёные клетки - рёбра сторон икосаэдра
        return greenType;
    }
}
    
///////////////////////////////////////////////////////////////////////////////////////
/// =============== Глобальная таблица Zobrist-ключей ==============================///
///////////////////////////////////////////////////////////////////////////////////////
// Инициализация таблиц Zobrist-ключей
const zobristCurrent = new Array(53);
const zobristPrevious = new Array(53);

for (let i = 1; i <= 52; i++) {
    zobristCurrent[i] = new Array(93);
    zobristPrevious[i] = new Array(93);
}

function initZobristKeys() {
    const seed = Date.now();
    let rand = seed;
    
    for (let i = 1; i <= 52; i++) {
        for (let u = 1; u <= 92; u++) {
            // Генерируем ключи для текущей позиции
            rand = (rand * 1664525 + 1013904223) % 0x100000000;
            zobristCurrent[i][u] = rand;
            
            // Генерируем ключи для предыдущей позиции
            rand = (rand * 1664525 + 1013904223) % 0x100000000;
            zobristPrevious[i][u] = rand;
        }
    }
}

function checkForErrors() {
    // Проверка размеров массивов Zobrist-ключей
    if (zobristCurrent.length !== 53 || zobristPrevious.length !== 53) {
        console.error("Некорректный размер массивов Zobrist-ключей");
        return false;
    }

    // Проверка заполнения таблиц
    for (let i = 1; i <= 52; i++) {
        if (zobristCurrent[i].length !== 93 || zobristPrevious[i].length !== 93) {
            console.error(`Некорректная длина подмассива для фигуры ${i}`);
            return false;
        }
        
        for (let u = 1; u <= 92; u++) {
            if (typeof zobristCurrent[i][u] !== 'number' || 
                typeof zobristPrevious[i][u] !== 'number') {
                console.error(`Некорректный тип данных для позиции ${i},${u}`);
                return false;
            }
        }
    }

    currentSystem = system;

    // Проверка системы на корректность данных
    if ((currentSystem[QUEUE] !== 1 && currentSystem[QUEUE] !== 2) && (currentSystem[MOVE] !==0)) {
        console.log(currentSystem[QUEUE], currentSystem[MOVE]);
        console.error("Некорректная очередь хода");
        return false;
    }

    // Проверка позиций фигур
    for (let i = 1; i <= 52; i++) {
        const currentField = currentSystem[UNIT_FIELD + i];
        const previousField = currentSystem[UNIT_PREV + i];
        
        if (currentField < 0 || currentField > 92) {
            console.error(`Некорректная текущая позиция фигуры ${i}`);
            return false;
        }
        
        if (previousField < 0 || previousField > 92) {
            console.error(`Некорректная предыдущая позиция фигуры ${i}`);
            return false;
        }
        
        if ((currentField === previousField && currentField !== 0) && (currentSystem[UNIT_SORT + i] !== C_helm)) {
            console.log(currentSystem[UNIT_FIELD + i]);
            console.error(`Фигура ${i} не может быть на одной и той же позиции`);
            return false;
        }
    }

    return true;
}

////////////////////////////////////////////////////////////////////////////////////////////////
// координаты для предрассчётов 
const icoVertices = [
/*    0   0    */   0.000000,   0.000000,   0.000000,     /*     0    0    0    */     
/*    1   1    */   0.000000,   0.000000,   1.000000,     /*   255    0    0    */ 
/*    1   2    */   0.000000,   0.000000,  -1.000000,     /*   255    0    0    */ 
/*    1   3    */  -0.894427,   0.000000,   0.447214,     /*   255    0    0    */ 
/*    1   4    */  -0.723607,  -0.525731,  -0.447214,     /*   255    0    0    */ 
/*    1   5    */  -0.276393,  -0.850651,   0.447214,     /*   255    0    0    */ 
/*    1   6    */   0.276393,  -0.850651,  -0.447214,     /*   255    0    0    */ 
/*    1   7    */   0.723607,  -0.525731,   0.447214,     /*   255    0    0    */ 
/*    1   8    */   0.894427,   0.000000,  -0.447214,     /*   255    0    0    */ 
/*    1   9    */   0.723607,   0.525731,   0.447214,     /*   255    0    0    */ 
/*    1  10    */   0.276393,   0.850651,  -0.447214,     /*   255    0    0    */ 
/*    1  11    */  -0.276393,   0.850651,   0.447214,     /*   255    0    0    */ 
/*    1  12    */  -0.723607,   0.525731,  -0.447214,     /*   255    0    0    */ 
/*    1  13    */  -0.491123,  -0.356822,   0.794654,     /*     0    0  255    */ 
/*    1  14    */  -0.491123,   0.356822,   0.794654,     /*     0    0  255    */ 
/*    1  15    */   0.187592,  -0.577350,   0.794654,     /*     0    0  255    */ 
/*    1  16    */   0.607062,   0.000000,   0.794654,     /*     0    0  255    */ 
/*    1  17    */   0.187592,   0.577350,   0.794654,     /*     0    0  255    */ 
/*    1  18    */  -0.187592,  -0.577350,  -0.794654,     /*     0    0  255    */ 
/*    1  19    */  -0.607062,   0.000000,  -0.794654,     /*     0    0  255    */ 
/*    1  20    */   0.491123,  -0.356822,  -0.794654,     /*     0    0  255    */ 
/*    1  21    */   0.491123,   0.356822,  -0.794654,     /*     0    0  255    */ 
/*    1  22    */  -0.187592,   0.577350,  -0.794654,     /*     0    0  255    */ 
/*    1  23    */  -0.794654,  -0.577350,   0.187592,     /*     0    0  255    */ 
/*    1  24    */  -0.982247,   0.000000,  -0.187592,     /*     0    0  255    */ 
/*    1  25    */  -0.794654,   0.577350,   0.187592,     /*     0    0  255    */ 
/*    1  26    */  -0.303531,  -0.934172,  -0.187592,     /*     0    0  255    */ 
/*    1  27    */   0.303531,  -0.934172,   0.187592,     /*     0    0  255    */ 
/*    1  28    */   0.794654,  -0.577350,  -0.187592,     /*     0    0  255    */ 
/*    1  29    */   0.982247,   0.000000,   0.187592,     /*     0    0  255    */ 
/*    1  30    */   0.794654,   0.577350,  -0.187592,     /*     0    0  255    */ 
/*    1  31    */   0.303531,   0.934172,   0.187592,     /*     0    0  255    */ 
/*    1  32    */  -0.303531,   0.934172,  -0.187592,     /*     0    0  255    */ 
/*    1  33    */  -0.354684,   0.000000,   0.934986,     /*     0  255    0    */ 
/*    1  34    */  -0.109603,  -0.337325,   0.934986,     /*     0  255    0    */ 
/*    1  35    */  -0.109603,   0.337325,   0.934986,     /*     0  255    0    */ 
/*    1  36    */   0.286946,  -0.208478,   0.934986,     /*     0  255    0    */ 
/*    1  37    */   0.286946,   0.208478,   0.934986,     /*     0  255    0    */ 
/*    1  38    */  -0.286946,  -0.208478,  -0.934986,     /*     0  255    0    */ 
/*    1  39    */   0.109603,  -0.337325,  -0.934986,     /*     0  255    0    */ 
/*    1  40    */  -0.286946,   0.208478,  -0.934986,     /*     0  255    0    */ 
/*    1  41    */   0.354684,   0.000000,  -0.934986,     /*     0  255    0    */ 
/*    1  42    */   0.109603,   0.337325,  -0.934986,     /*     0  255    0    */ 
/*    1  43    */  -0.677657,   0.000000,   0.735378,     /*     0  255    0    */ 
/*    1  44    */  -0.787261,  -0.337325,   0.516171,     /*     0  255    0    */ 
/*    1  45    */  -0.787261,   0.337325,   0.516171,     /*     0  255    0    */ 
/*    1  46    */  -0.964603,  -0.208478,   0.161487,     /*     0  255    0    */ 
/*    1  47    */  -0.964603,   0.208478,   0.161487,     /*     0  255    0    */ 
/*    1  48    */  -0.548236,  -0.398317,  -0.735378,     /*     0  255    0    */ 
/*    1  49    */  -0.438633,  -0.735642,  -0.516171,     /*     0  255    0    */ 
/*    1  50    */  -0.835182,  -0.189839,  -0.516171,     /*     0  255    0    */ 
/*    1  51    */  -0.902921,  -0.398317,  -0.161487,     /*     0  255    0    */ 
/*    1  52    */  -0.657840,  -0.735642,  -0.161487,     /*     0  255    0    */ 
/*    1  53    */  -0.209408,  -0.644490,   0.735378,     /*     0  255    0    */ 
/*    1  54    */  -0.564092,  -0.644490,   0.516171,     /*     0  255    0    */ 
/*    1  55    */   0.077538,  -0.852969,   0.516171,     /*     0  255    0    */ 
/*    1  56    */  -0.496353,  -0.852969,   0.161487,     /*     0  255    0    */ 
/*    1  57    */  -0.099804,  -0.981815,   0.161487,     /*     0  255    0    */ 
/*    1  58    */   0.209408,  -0.644490,  -0.735378,     /*     0  255    0    */ 
/*    1  59    */  -0.077538,  -0.852969,  -0.516171,     /*     0  255    0    */ 
/*    1  60    */   0.564092,  -0.644490,  -0.516171,     /*     0  255    0    */ 
/*    1  61    */   0.099804,  -0.981815,  -0.161487,     /*     0  255    0    */ 
/*    1  62    */   0.496353,  -0.852969,  -0.161487,     /*     0  255    0    */ 
/*    1  63    */   0.548236,  -0.398317,   0.735378,     /*     0  255    0    */ 
/*    1  64    */   0.438633,  -0.735642,   0.516171,     /*     0  255    0    */ 
/*    1  65    */   0.835182,  -0.189839,   0.516171,     /*     0  255    0    */ 
/*    1  66    */   0.657840,  -0.735642,   0.161487,     /*     0  255    0    */ 
/*    1  67    */   0.902921,  -0.398317,   0.161487,     /*     0  255    0    */ 
/*    1  68    */   0.677657,   0.000000,  -0.735378,     /*     0  255    0    */ 
/*    1  69    */   0.787261,  -0.337325,  -0.516171,     /*     0  255    0    */ 
/*    1  70    */   0.787261,   0.337325,  -0.516171,     /*     0  255    0    */ 
/*    1  71    */   0.964603,  -0.208478,  -0.161487,     /*     0  255    0    */ 
/*    1  72    */   0.964603,   0.208478,  -0.161487,     /*     0  255    0    */ 
/*    1  73    */   0.548236,   0.398317,   0.735378,     /*     0  255    0    */ 
/*    1  74    */   0.835182,   0.189839,   0.516171,     /*     0  255    0    */ 
/*    1  75    */   0.438633,   0.735642,   0.516171,     /*     0  255    0    */ 
/*    1  76    */   0.902921,   0.398317,   0.161487,     /*     0  255    0    */ 
/*    1  77    */   0.657840,   0.735642,   0.161487,     /*     0  255    0    */ 
/*    1  78    */   0.209408,   0.644490,  -0.735378,     /*     0  255    0    */ 
/*    1  79    */   0.564092,   0.644490,  -0.516171,     /*     0  255    0    */ 
/*    1  80    */  -0.077538,   0.852969,  -0.516171,     /*     0  255    0    */ 
/*    1  81    */   0.496353,   0.852969,  -0.161487,     /*     0  255    0    */ 
/*    1  82    */   0.099804,   0.981815,  -0.161487,     /*     0  255    0    */ 
/*    1  83    */  -0.209408,   0.644490,   0.735378,     /*     0  255    0    */ 
/*    1  84    */  -0.564092,   0.644490,   0.516171,     /*     0  255    0    */ 
/*    1  85    */   0.077538,   0.852969,   0.516171,     /*     0  255    0    */ 
/*    1  86    */  -0.496353,   0.852969,   0.161487,     /*     0  255    0    */ 
/*    1  87    */  -0.099804,   0.981815,   0.161487,     /*     0  255    0    */ 
/*    1  88    */  -0.548236,   0.398317,  -0.735378,     /*     0  255    0    */ 
/*    1  89    */  -0.835182,   0.189839,  -0.516171,     /*     0  255    0    */ 
/*    1  90    */  -0.438633,   0.735642,  -0.516171,     /*     0  255    0    */ 
/*    1  91    */  -0.902921,   0.398317,  -0.161487,     /*     0  255    0    */ 
/*    1  92    */  -0.657840,   0.735642,  -0.161487,     /*     0  255    0    */ 
/*    0  93    */  -0.158634,  -0.115254,   0.980587,     /*   100  100  100    */ 
/*    0  94    */  -0.158634,   0.115254,   0.980587,     /*   100  100  100    */ 
/*    0  95    */   0.060593,  -0.186485,   0.980587,     /*   100  100  100    */ 
/*    0  96    */   0.060593,   0.186485,   0.980587,     /*   100  100  100    */ 
/*    0  97    */   0.196082,   0.000000,   0.980587,     /*   100  100  100    */ 
/*    0  98    */  -0.060593,  -0.186485,  -0.980587,     /*   100  100  100    */ 
/*    0  99    */  -0.196082,   0.000000,  -0.980587,     /*   100  100  100    */ 
/*    0 100    */   0.158634,  -0.115254,  -0.980587,     /*   100  100  100    */ 
/*    0 101    */  -0.060593,   0.186485,  -0.980587,     /*   100  100  100    */ 
/*    0 102    */   0.158634,   0.115254,  -0.980587,     /*   100  100  100    */ 
/*    0 103    */  -0.806121,  -0.115254,   0.580418,     /*   100  100  100    */ 
/*    0 104    */  -0.806121,   0.115254,   0.580418,     /*   100  100  100    */ 
/*    0 105    */  -0.904162,  -0.186485,   0.384336,     /*   100  100  100    */ 
/*    0 106    */  -0.904162,   0.186485,   0.384336,     /*   100  100  100    */ 
/*    0 107    */  -0.964755,   0.000000,   0.263151,     /*   100  100  100    */ 
/*    0 108    */  -0.584421,  -0.567069,  -0.580418,     /*   100  100  100    */ 
/*    0 109    */  -0.719910,  -0.380583,  -0.580418,     /*   100  100  100    */ 
/*    0 110    */  -0.621869,  -0.682323,  -0.384336,     /*   100  100  100    */ 
/*    0 111    */  -0.841096,  -0.380583,  -0.384336,     /*   100  100  100    */ 
/*    0 112    */  -0.780503,  -0.567069,  -0.263151,     /*   100  100  100    */ 
/*    0 113    */  -0.358718,  -0.731051,   0.580418,     /*   100  100  100    */ 
/*    0 114    */  -0.139492,  -0.802282,   0.580418,     /*   100  100  100    */ 
/*    0 115    */  -0.456759,  -0.802282,   0.384336,     /*   100  100  100    */ 
/*    0 116    */  -0.102043,  -0.917536,   0.384336,     /*   100  100  100    */ 
/*    0 117    */  -0.298126,  -0.917536,   0.263151,     /*   100  100  100    */ 
/*    0 118    */   0.139492,  -0.802282,  -0.580418,     /*   100  100  100    */ 
/*    0 119    */   0.358718,  -0.731051,  -0.580418,     /*   100  100  100    */ 
/*    0 120    */   0.102043,  -0.917536,  -0.384336,     /*   100  100  100    */ 
/*    0 121    */   0.456759,  -0.802282,  -0.384336,     /*   100  100  100    */ 
/*    0 122    */   0.298126,  -0.917536,  -0.263151,     /*   100  100  100    */ 
/*    0 123    */   0.584421,  -0.567069,   0.580418,     /*   100  100  100    */ 
/*    0 124    */   0.719910,  -0.380583,   0.580418,     /*   100  100  100    */ 
/*    0 125    */   0.621869,  -0.682323,   0.384336,     /*   100  100  100    */ 
/*    0 126    */   0.841096,  -0.380583,   0.384336,     /*   100  100  100    */ 
/*    0 127    */   0.780503,  -0.567069,   0.263151,     /*   100  100  100    */ 
/*    0 128    */   0.806121,  -0.115254,  -0.580418,     /*   100  100  100    */ 
/*    0 129    */   0.806121,   0.115254,  -0.580418,     /*   100  100  100    */ 
/*    0 130    */   0.904162,  -0.186485,  -0.384336,     /*   100  100  100    */ 
/*    0 131    */   0.904162,   0.186485,  -0.384336,     /*   100  100  100    */ 
/*    0 132    */   0.964755,   0.000000,  -0.263151,     /*   100  100  100    */ 
/*    0 133    */   0.719910,   0.380583,   0.580418,     /*   100  100  100    */ 
/*    0 134    */   0.584421,   0.567069,   0.580418,     /*   100  100  100    */ 
/*    0 135    */   0.841096,   0.380583,   0.384336,     /*   100  100  100    */ 
/*    0 136    */   0.621869,   0.682323,   0.384336,     /*   100  100  100    */ 
/*    0 137    */   0.780503,   0.567069,   0.263151,     /*   100  100  100    */ 
/*    0 138    */   0.358718,   0.731051,  -0.580418,     /*   100  100  100    */ 
/*    0 139    */   0.139492,   0.802282,  -0.580418,     /*   100  100  100    */ 
/*    0 140    */   0.456759,   0.802282,  -0.384336,     /*   100  100  100    */ 
/*    0 141    */   0.102043,   0.917536,  -0.384336,     /*   100  100  100    */ 
/*    0 142    */   0.298126,   0.917536,  -0.263151,     /*   100  100  100    */ 
/*    0 143    */  -0.358718,   0.731051,   0.580418,     /*   100  100  100    */ 
/*    0 144    */  -0.139492,   0.802282,   0.580418,     /*   100  100  100    */ 
/*    0 145    */  -0.456759,   0.802282,   0.384336,     /*   100  100  100    */ 
/*    0 146    */  -0.102043,   0.917536,   0.384336,     /*   100  100  100    */ 
/*    0 147    */  -0.298126,   0.917536,   0.263151,     /*   100  100  100    */ 
/*    0 148    */  -0.719910,   0.380583,  -0.580418,     /*   100  100  100    */ 
/*    0 149    */  -0.584421,   0.567069,  -0.580418,     /*   100  100  100    */ 
/*    0 150    */  -0.841096,   0.380583,  -0.384336,     /*   100  100  100    */ 
/*    0 151    */  -0.621869,   0.682323,  -0.384336,     /*   100  100  100    */ 
/*    0 152    */  -0.780503,   0.567069,  -0.263151,     /*   100  100  100    */ 
/*    0 153    */  -0.327802,  -0.238162,   0.914234,     /*   100  100  100    */ 
/*    0 154    */  -0.521790,  -0.122212,   0.844274,     /*   100  100  100    */ 
/*    0 155    */  -0.277473,  -0.458486,   0.844274,     /*   100  100  100    */ 
/*    0 156    */  -0.671119,  -0.238162,   0.702053,     /*   100  100  100    */ 
/*    0 157    */  -0.631052,  -0.458486,   0.625750,     /*   100  100  100    */ 
/*    0 158    */  -0.433893,  -0.564676,   0.702053,     /*   100  100  100    */ 
/*    0 159    */  -0.327802,   0.238162,   0.914234,     /*   100  100  100    */ 
/*    0 160    */  -0.521790,   0.122212,   0.844274,     /*   100  100  100    */ 
/*    0 161    */  -0.277473,   0.458486,   0.844274,     /*   100  100  100    */ 
/*    0 162    */  -0.671119,   0.238162,   0.702053,     /*   100  100  100    */ 
/*    0 163    */  -0.631052,   0.458486,   0.625750,     /*   100  100  100    */ 
/*    0 164    */  -0.433893,   0.564676,   0.702053,     /*   100  100  100    */ 
/*    0 165    */   0.125209,  -0.385354,   0.914234,     /*   100  100  100    */ 
/*    0 166    */  -0.045011,  -0.534018,   0.844274,     /*   100  100  100    */ 
/*    0 167    */   0.350303,  -0.405572,   0.844274,     /*   100  100  100    */ 
/*    0 168    */   0.019119,  -0.711868,   0.702053,     /*   100  100  100    */ 
/*    0 169    */   0.241041,  -0.741846,   0.625750,     /*   100  100  100    */ 
/*    0 170    */   0.402958,  -0.587151,   0.702053,     /*   100  100  100    */ 
/*    0 171    */   0.405186,   0.000000,   0.914234,     /*   100  100  100    */ 
/*    0 172    */   0.493972,  -0.207829,   0.844274,     /*   100  100  100    */ 
/*    0 173    */   0.493972,   0.207829,   0.844274,     /*   100  100  100    */ 
/*    0 174    */   0.682935,  -0.201796,   0.702053,     /*   100  100  100    */ 
/*    0 175    */   0.780023,   0.000000,   0.625750,     /*   100  100  100    */ 
/*    0 176    */   0.682935,   0.201796,   0.702053,     /*   100  100  100    */ 
/*    0 177    */   0.125209,   0.385354,   0.914234,     /*   100  100  100    */ 
/*    0 178    */  -0.045011,   0.534018,   0.844274,     /*   100  100  100    */ 
/*    0 179    */   0.350303,   0.405572,   0.844274,     /*   100  100  100    */ 
/*    0 180    */   0.402958,   0.587151,   0.702053,     /*   100  100  100    */ 
/*    0 181    */   0.241041,   0.741846,   0.625750,     /*   100  100  100    */ 
/*    0 182    */   0.019119,   0.711868,   0.702053,     /*   100  100  100    */ 
/*    0 183    */  -0.125209,  -0.385354,  -0.914234,     /*   100  100  100    */ 
/*    0 184    */  -0.350303,  -0.405572,  -0.844274,     /*   100  100  100    */ 
/*    0 185    */   0.045011,  -0.534018,  -0.844274,     /*   100  100  100    */ 
/*    0 186    */  -0.402958,  -0.587151,  -0.702053,     /*   100  100  100    */ 
/*    0 187    */  -0.241041,  -0.741846,  -0.625750,     /*   100  100  100    */ 
/*    0 188    */  -0.019119,  -0.711868,  -0.702053,     /*   100  100  100    */ 
/*    0 189    */  -0.405186,   0.000000,  -0.914234,     /*   100  100  100    */ 
/*    0 190    */  -0.493972,  -0.207829,  -0.844274,     /*   100  100  100    */ 
/*    0 191    */  -0.493972,   0.207829,  -0.844274,     /*   100  100  100    */ 
/*    0 192    */  -0.682935,  -0.201796,  -0.702053,     /*   100  100  100    */ 
/*    0 193    */  -0.780023,   0.000000,  -0.625750,     /*   100  100  100    */ 
/*    0 194    */  -0.682935,   0.201796,  -0.702053,     /*   100  100  100    */ 
/*    0 195    */   0.327802,  -0.238162,  -0.914234,     /*   100  100  100    */ 
/*    0 196    */   0.277473,  -0.458486,  -0.844274,     /*   100  100  100    */ 
/*    0 197    */   0.521790,  -0.122212,  -0.844274,     /*   100  100  100    */ 
/*    0 198    */   0.433893,  -0.564676,  -0.702053,     /*   100  100  100    */ 
/*    0 199    */   0.631052,  -0.458486,  -0.625750,     /*   100  100  100    */ 
/*    0 200    */   0.671119,  -0.238162,  -0.702053,     /*   100  100  100    */ 
/*    0 201    */   0.327802,   0.238162,  -0.914234,     /*   100  100  100    */ 
/*    0 202    */   0.521790,   0.122212,  -0.844274,     /*   100  100  100    */ 
/*    0 203    */   0.277473,   0.458486,  -0.844274,     /*   100  100  100    */ 
/*    0 204    */   0.671119,   0.238162,  -0.702053,     /*   100  100  100    */ 
/*    0 205    */   0.631052,   0.458486,  -0.625750,     /*   100  100  100    */ 
/*    0 206    */   0.433893,   0.564676,  -0.702053,     /*   100  100  100    */ 
/*    0 207    */  -0.125209,   0.385354,  -0.914234,     /*   100  100  100    */ 
/*    0 208    */  -0.350303,   0.405572,  -0.844274,     /*   100  100  100    */ 
/*    0 209    */   0.045011,   0.534018,  -0.844274,     /*   100  100  100    */ 
/*    0 210    */  -0.019119,   0.711868,  -0.702053,     /*   100  100  100    */ 
/*    0 211    */  -0.241041,   0.741846,  -0.625750,     /*   100  100  100    */ 
/*    0 212    */  -0.402958,   0.587151,  -0.702053,     /*   100  100  100    */ 
/*    0 213    */  -0.873711,  -0.385354,   0.296868,     /*   100  100  100    */ 
/*    0 214    */  -0.735012,  -0.534018,   0.417830,     /*   100  100  100    */ 
/*    0 215    */  -0.911802,  -0.405572,   0.064251,     /*   100  100  100    */ 
/*    0 216    */  -0.808144,  -0.587151,  -0.046449,     /*   100  100  100    */ 
/*    0 217    */  -0.667485,  -0.741846,   0.064251,     /*   100  100  100    */ 
/*    0 218    */  -0.636485,  -0.711868,   0.296868,     /*   100  100  100    */ 
/*    0 219    */  -0.998921,   0.000000,   0.046449,     /*   100  100  100    */ 
/*    0 220    */  -0.976053,  -0.207829,  -0.064251,     /*   100  100  100    */ 
/*    0 221    */  -0.976053,   0.207829,  -0.064251,     /*   100  100  100    */ 
/*    0 222    */  -0.933353,  -0.201796,  -0.296868,     /*   100  100  100    */ 
/*    0 223    */  -0.908525,   0.000000,  -0.417830,     /*   100  100  100    */ 
/*    0 224    */  -0.933353,   0.201796,  -0.296868,     /*   100  100  100    */ 
/*    0 225    */  -0.873711,   0.385354,   0.296868,     /*   100  100  100    */ 
/*    0 226    */  -0.735012,   0.534018,   0.417830,     /*   100  100  100    */ 
/*    0 227    */  -0.911802,   0.405572,   0.064251,     /*   100  100  100    */ 
/*    0 228    */  -0.636485,   0.711868,   0.296868,     /*   100  100  100    */ 
/*    0 229    */  -0.667485,   0.741846,   0.064251,     /*   100  100  100    */ 
/*    0 230    */  -0.808144,   0.587151,  -0.046449,     /*   100  100  100    */ 
/*    0 231    */  -0.480342,  -0.825313,  -0.296868,     /*   100  100  100    */ 
/*    0 232    */  -0.280750,  -0.864059,  -0.417830,     /*   100  100  100    */ 
/*    0 233    */  -0.499274,  -0.864059,  -0.064251,     /*   100  100  100    */ 
/*    0 234    */  -0.308683,  -0.950030,   0.046449,     /*   100  100  100    */ 
/*    0 235    */  -0.103960,  -0.992504,  -0.064251,     /*   100  100  100    */ 
/*    0 236    */  -0.096502,  -0.950030,  -0.296868,     /*   100  100  100    */ 
/*    0 237    */   0.096502,  -0.950030,   0.296868,     /*   100  100  100    */ 
/*    0 238    */   0.280750,  -0.864059,   0.417830,     /*   100  100  100    */ 
/*    0 239    */   0.103960,  -0.992504,   0.064251,     /*   100  100  100    */ 
/*    0 240    */   0.308683,  -0.950030,  -0.046449,     /*   100  100  100    */ 
/*    0 241    */   0.499274,  -0.864059,   0.064251,     /*   100  100  100    */ 
/*    0 242    */   0.480342,  -0.825313,   0.296868,     /*   100  100  100    */ 
/*    0 243    */   0.636485,  -0.711868,  -0.296868,     /*   100  100  100    */ 
/*    0 244    */   0.735012,  -0.534018,  -0.417830,     /*   100  100  100    */ 
/*    0 245    */   0.667485,  -0.741846,  -0.064251,     /*   100  100  100    */ 
/*    0 246    */   0.808144,  -0.587151,   0.046449,     /*   100  100  100    */ 
/*    0 247    */   0.911802,  -0.405572,  -0.064251,     /*   100  100  100    */ 
/*    0 248    */   0.873711,  -0.385354,  -0.296868,     /*   100  100  100    */ 
/*    0 249    */   0.933353,  -0.201796,   0.296868,     /*   100  100  100    */ 
/*    0 250    */   0.908525,   0.000000,   0.417830,     /*   100  100  100    */ 
/*    0 251    */   0.976053,  -0.207829,   0.064251,     /*   100  100  100    */ 
/*    0 252    */   0.998921,   0.000000,  -0.046449,     /*   100  100  100    */ 
/*    0 253    */   0.976053,   0.207829,   0.064251,     /*   100  100  100    */ 
/*    0 254    */   0.933353,   0.201796,   0.296868,     /*   100  100  100    */ 
/*    0 255    */   0.873711,   0.385354,  -0.296868,     /*   100  100  100    */ 
/*    0 256    */   0.735012,   0.534018,  -0.417830,     /*   100  100  100    */ 
/*    0 257    */   0.911802,   0.405572,  -0.064251,     /*   100  100  100    */ 
/*    0 258    */   0.808144,   0.587151,   0.046449,     /*   100  100  100    */ 
/*    0 259    */   0.667485,   0.741846,  -0.064251,     /*   100  100  100    */ 
/*    0 260    */   0.636485,   0.711868,  -0.296868,     /*   100  100  100    */ 
/*    0 261    */   0.480342,   0.825313,   0.296868,     /*   100  100  100    */ 
/*    0 262    */   0.280750,   0.864059,   0.417830,     /*   100  100  100    */ 
/*    0 263    */   0.499274,   0.864059,   0.064251,     /*   100  100  100    */ 
/*    0 264    */   0.308683,   0.950030,  -0.046449,     /*   100  100  100    */ 
/*    0 265    */   0.103960,   0.992504,   0.064251,     /*   100  100  100    */ 
/*    0 266    */   0.096502,   0.950030,   0.296868,     /*   100  100  100    */ 
/*    0 267    */  -0.096502,   0.950030,  -0.296868,     /*   100  100  100    */ 
/*    0 268    */  -0.280750,   0.864059,  -0.417830,     /*   100  100  100    */ 
/*    0 269    */  -0.103960,   0.992504,  -0.064251,     /*   100  100  100    */ 
/*    0 270    */  -0.308683,   0.950030,   0.046449,     /*   100  100  100    */ 
/*    0 271    */  -0.499274,   0.864059,  -0.064251,     /*   100  100  100    */ 
/*    0 272    */  -0.480342,   0.825313,  -0.296868,     /*   100  100  100    */ 
 ];

///////////////////////////////   Соседи   //////////////////////////////
const next = [];
next[ 0] = null;                                           
/////////////   Красные   /////////////
next[ 1] = new Set([33,34,35,36,37]);                                  
next[ 2] = new Set([38,39,40,41,42]);
next[ 3] = new Set([43,44,45,46,47]);
next[ 4] = new Set([48,49,50,51,52]);
next[ 5] = new Set([53,54,55,56,57]);
next[ 6] = new Set([58,59,60,61,62]);
next[ 7] = new Set([63,64,65,66,67]);
next[ 8] = new Set([68,69,70,71,72]);
next[ 9] = new Set([73,74,75,76,77]);
next[10] = new Set([78,79,80,81,82]);
next[11] = new Set([83,84,85,86,87]);
next[12] = new Set([88,89,90,91,92]);
/////////////   Синие   /////////////
next[13] = new Set([33,34,43,44,53,54]);                               
next[14] = new Set([83,84,45,43,33,35]);
next[15] = new Set([53,55,64,63,36,34]);
next[16] = new Set([63,65,74,73,37,36]);
next[17] = new Set([73,75,85,83,35,37]);
next[18] = new Set([38,39,48,49,58,59]);
next[19] = new Set([40,38,48,88,89,50]);
next[20] = new Set([39,41,68,58,60,69]);
next[21] = new Set([68,41,42,78,79,70]);
next[22] = new Set([78,42,40,88,90,80]);
next[23] = new Set([46,44,54,56,52,51]);
next[24] = new Set([47,46,51,50,89,91]);
next[25] = new Set([86,84,45,47,91,92]);
next[26] = new Set([52,56,57,61,59,49]);
next[27] = new Set([57,55,64,66,62,61]);
next[28] = new Set([60,62,66,67,71,69]);
next[29] = new Set([71,67,65,74,76,72]);
next[30] = new Set([70,72,76,77,81,79]);
next[31] = new Set([81,77,75,85,87,82]);
next[32] = new Set([80,82,87,86,92,90]);
/////////////  Зелёные   /////////////
next[33] = new Set([ 1,35,14,43,13,34]);                               
next[34] = new Set([ 1,33,13,53,15,36]);
next[35] = new Set([ 1,37,17,83,14,33]);
next[36] = new Set([ 1,34,15,63,16,37]);
next[37] = new Set([ 1,36,16,73,17,35]);

next[38] = new Set([ 2,39,18,48,19,40]);
next[39] = new Set([ 2,41,20,58,18,38]);
next[40] = new Set([ 2,38,19,88,22,42]);
next[41] = new Set([ 2,42,21,68,20,39]);
next[42] = new Set([ 2,40,22,78,21,41]);
	
next[43] = new Set([ 3,45,14,33,13,44]);
next[44] = new Set([ 3,46,23,54,13,43]);
next[45] = new Set([ 3,43,14,84,25,47]);
next[46] = new Set([ 3,44,23,51,24,47]);
next[47] = new Set([ 3,45,25,91,24,46]);

next[48] = new Set([ 4,50,19,38,18,49]);
next[49] = new Set([ 4,48,18,59,26,52]);
next[50] = new Set([ 4,51,24,89,19,48]);
next[51] = new Set([ 4,52,23,46,24,50]);
next[52] = new Set([ 4,51,23,56,26,49]);

next[53] = new Set([ 5,54,13,34,15,55]);
next[54] = new Set([ 5,53,13,44,23,56]);
next[55] = new Set([ 5,53,15,64,27,57]);
next[56] = new Set([ 5,54,23,52,26,57]);
next[57] = new Set([ 5,56,26,61,27,55]);

next[58] = new Set([ 6,59,18,39,20,60]);
next[59] = new Set([ 6,61,26,49,18,58]);
next[60] = new Set([ 6,62,28,69,20,58]);
next[61] = new Set([ 6,59,26,57,27,62]);
next[62] = new Set([ 6,61,27,66,28,60]);

next[63] = new Set([ 7,64,15,36,16,65]);
next[64] = new Set([ 7,63,15,55,27,66]);
next[65] = new Set([ 7,63,16,74,29,67]);
next[66] = new Set([ 7,64,27,62,28,67]);
next[67] = new Set([ 7,66,28,71,29,65]);

next[68] = new Set([ 8,69,20,41,21,70]);
next[69] = new Set([ 8,71,28,60,20,68]);
next[70] = new Set([ 8,72,30,79,21,68]);
next[71] = new Set([ 8,72,29,67,28,69]);
next[72] = new Set([ 8,71,29,76,30,70]);

next[73] = new Set([ 9,74,16,37,17,75]);
next[74] = new Set([ 9,76,29,65,16,73]);
next[75] = new Set([ 9,73,17,85,31,77]);
next[76] = new Set([ 9,74,29,72,30,77]);
next[77] = new Set([ 9,76,30,81,31,75]);

next[78] = new Set([10,79,21,42,22,80]);
next[79] = new Set([10,81,30,70,21,78]);
next[80] = new Set([10,82,32,90,22,78]);
next[81] = new Set([10,82,31,77,30,79]);
next[82] = new Set([10,81,31,87,32,80]);

next[83] = new Set([11,17,14,84,85,35]);
next[84] = new Set([11,83,14,45,25,86]);
next[85] = new Set([11,87,31,75,17,83]);
next[86] = new Set([11,84,25,92,32,87]);
next[87] = new Set([11,85,31,82,32,86]);
	
next[88] = new Set([12,90,22,40,19,89]);
next[89] = new Set([12,91,24,50,19,88]);
next[90] = new Set([12,92,32,80,22,88]);
next[91] = new Set([12,92,25,47,24,89]);
next[92] = new Set([12,90,32,86,25,91]);

const lSet = new Set ([33, 34, 35, 36, 37]);
const dSet = new Set ([38, 39, 40, 41, 42]);
	
const starArrow = [];
const starHelm = [];
for (i = 0; i <= 92; i++) {
    starArrow[i] = next[i];
    starHelm[i]  = next[i];
}

const beamArrow = [[[]]],
      moveArrow = [[[]]],
   captureArrow = [[[]]],
 firstMoveArrow = [[[]]],
firstCaptureArrow = [[[]]];

// ОДИНАРНЫЕ Пучки для пешек
   beamArrow[0] = null;
   moveArrow[0] = null;
captureArrow[0] = null;

for (p = 1; p <= 92; p++) {
       beamArrow[p] = [];
       moveArrow[p] = [];
    captureArrow[p] = [];
    
    for (v = 13; v <= 92; v++) {
        if (next[v].has(p)) {
            
            beamArrow[p][v] = new Set();
            moveArrow[p][v] = new Set();
            captureArrow[p][v] = new Set();
            
            starArrow[v].forEach(function(number) { 
                if (!next[p].has(number) && (next[v].has(number)) && (number !== p)) {
                    beamArrow[p][v].add(number);
                }
            });
            
            beamArrow[p][v].forEach(function(number1) {
                beamArrow[p][v].forEach(function(number2) {
                    beamArrow[p][v].forEach(function(number3) {
                        if ((number1 !== number2) && (number1 !== number3) && (number2 !== number3)) {
                            if (next[number3].has(number1) &&  next[number3].has(number2)) {
                                moveArrow[p][v].add(number3);
                            }
                            if (next[number3].has(number1) && !next[number3].has(number2)) {
                                captureArrow[p][v].add(number3);
                            }
                        }
                    });
                });
            });
        }
    }
    
    for (v = 1; v <= 12; v++) {
        if (next[v].has(p)) {
            
            beamArrow[p][v] = new Set();
            moveArrow[p][v] = new Set();
            captureArrow[p][v] = new Set();
            
            starArrow[v].forEach(function(number) { 
                beamArrow[p][v].add(number);
                moveArrow[p][v].add(number);
             captureArrow[p][v].add(number);
            });
        }  
    }
}

const pv = [];
pv[1] =  [1, 44, 54, 55, 64, 65, 74, 75, 85, 84, 45];
pv[2] =  [2, 69, 60, 59, 49, 50, 89, 90, 80, 79, 70];

const p0 = [];
for (let i = 0; i <= 92; i++) {
    p0[i] = [0, 0, 0];
}

p0[44] = [1, 13, 43];
p0[54] = [1, 13, 53];
p0[55] = [1, 15, 53];
p0[64] = [1, 15, 63];
p0[65] = [1, 16, 63];
p0[74] = [1, 16, 73];
p0[75] = [1, 17, 73];
p0[85] = [1, 17, 83];
p0[84] = [1, 14, 83];
p0[45] = [1, 14, 43];

p0[69] = [2, 20, 68];
p0[60] = [2, 20, 58];
p0[59] = [2, 18, 58];
p0[49] = [2, 18, 48];
p0[50] = [2, 19, 48];
p0[89] = [2, 19, 88];
p0[90] = [2, 22, 88];
p0[80] = [2, 22, 78];
p0[79] = [2, 21, 78];
p0[70] = [2, 21, 68];

firstCaptureArrow[0] = null;

for (let i = 1; i <= 2; i++) {
    firstCaptureArrow[i]= [];
    
    for (let j = 1; j <= 10; j++) {
        const p = pv[i][0];
        const v = pv[i][j];
        
        firstCaptureArrow[p][v] = new Set;
        firstCaptureArrow[p][v] = starArrow[v];
    }
}

firstMoveArrow[0] = null;

firstMoveArrow[1] = [];
firstMoveArrow[1][44] = new Set([46, 23]); 
firstMoveArrow[1][54] = new Set([23, 56]); 
firstMoveArrow[1][55] = new Set([57, 27]); 
firstMoveArrow[1][64] = new Set([27, 66]); 
firstMoveArrow[1][65] = new Set([67, 29]); 
firstMoveArrow[1][74] = new Set([29, 76]); 
firstMoveArrow[1][75] = new Set([77, 31]); 
firstMoveArrow[1][85] = new Set([31, 87]); 
firstMoveArrow[1][84] = new Set([86, 25]); 
firstMoveArrow[1][45] = new Set([25, 47]); 

firstMoveArrow[2] = [];
firstMoveArrow[2][69] = new Set([71, 28]); 
firstMoveArrow[2][60] = new Set([28, 62]); 
firstMoveArrow[2][59] = new Set([61, 26]); 
firstMoveArrow[2][49] = new Set([26, 52]); 
firstMoveArrow[2][50] = new Set([51, 24]); 
firstMoveArrow[2][89] = new Set([24, 91]); 
firstMoveArrow[2][90] = new Set([92, 32]); 
firstMoveArrow[2][80] = new Set([32, 82]); 
firstMoveArrow[2][79] = new Set([81, 30]); 
firstMoveArrow[2][70] = new Set([30, 72]); 

////////////////////////////   Рокировка Шлема   ///////////////////////////
const starOfCastling = [];
starOfCastling[ 0] = null;

/////////////   Красные   /////////////
starOfCastling[ 1] = new Set([ 7, 9,11, 3, 5]);
starOfCastling[ 2] = new Set([ 6, 4,12, 8,10]);    
starOfCastling[ 3] = new Set([ 1, 5, 4,12,11]);
starOfCastling[ 4] = new Set([ 3, 5, 6, 2,12]);
starOfCastling[ 5] = new Set([ 1, 7, 6, 4, 3]);
starOfCastling[ 6] = new Set([ 5, 7, 8, 2, 4]);
starOfCastling[ 7] = new Set([ 1, 9, 8, 6, 5]);
starOfCastling[ 8] = new Set([ 7, 9,10, 2, 6]);
starOfCastling[ 9] = new Set([ 1,11,10, 8, 7]);
starOfCastling[10] = new Set([ 9,11,12, 2, 8]);
starOfCastling[11] = new Set([ 1, 3,12,10, 9]);
starOfCastling[12] = new Set([11, 3, 4, 2,10]);

for (i =  13; i <= 92; i++) {
    starOfCastling[ i] = null;
}

///////////////////////////////  Слоны (Пики)   /////////////////////////////////
const starPike = [[[]]];
starPike[ 0] = null;
/////////////   Красные   /////////////
starPike[ 1]    = [];                                                     
starPike[ 1][0] = null;
starPike[ 1][1] = [ 0,15,27, 6]; 
starPike[ 1][2] = [ 0,13,23, 4];
starPike[ 1][3] = [ 0,14,25,12];
starPike[ 1][4] = [ 0,16,29, 8];
starPike[ 1][5] = [ 0,17,31,10];
  
starPike[ 2]    = [];                                                     
starPike[ 2][0] = null;
starPike[ 2][1] = [ 0,20,28, 7]; 
starPike[ 2][2] = [ 0,21,30, 9];
starPike[ 2][3] = [ 0,22,32,11];
starPike[ 2][4] = [ 0,19,24, 3];
starPike[ 2][5] = [ 0,18,26, 5];

starPike[ 3]    = [];
starPike[ 3][0] = null;
starPike[ 3][1] = [ 0,24,19, 2]; 
starPike[ 3][2] = [ 0,23,26, 6];
starPike[ 3][3] = [ 0,13,15, 7];
starPike[ 3][4] = [ 0,14,17, 9];
starPike[ 3][5] = [ 0,25,32,10];

starPike[ 4]    = [];
starPike[ 4][0] = null;
starPike[ 4][1] = [ 0,23,13, 1]; 
starPike[ 4][2] = [ 0,26,27, 7];
starPike[ 4][3] = [ 0,18,20, 8];
starPike[ 4][4] = [ 0,19,22,10];
starPike[ 4][5] = [ 0,24,25,11];

starPike[ 5]    = [];
starPike[ 5][0] = null;
starPike[ 5][1] = [ 0,26,18, 2]; 
starPike[ 5][2] = [ 0,27,28, 8];
starPike[ 5][3] = [ 0,15,16, 9];
starPike[ 5][4] = [ 0,13,14,11];
starPike[ 5][5] = [ 0,23,24,12];

starPike[ 6]    = [];
starPike[ 6][0] = null;
starPike[ 6][1] = [ 0,27,15, 1]; 
starPike[ 6][2] = [ 0,28,29, 9];
starPike[ 6][3] = [ 0,20,21,10];
starPike[ 6][4] = [ 0,18,19,12];
starPike[ 6][5] = [ 0,26,23, 3];

starPike[ 7]    = [];
starPike[ 7][0] = null;
starPike[ 7][1] = [ 0,28,20, 2]; 
starPike[ 7][2] = [ 0,29,30,10];
starPike[ 7][3] = [ 0,16,17,11];
starPike[ 7][4] = [ 0,15,13, 3];
starPike[ 7][5] = [ 0,27,26, 4];

starPike[ 8]    = [];
starPike[ 8][0] = null;
starPike[ 8][1] = [ 0,29,16, 1]; 
starPike[ 8][2] = [ 0,30,31,11];
starPike[ 8][3] = [ 0,21,22,12];
starPike[ 8][4] = [ 0,20,18, 4];
starPike[ 8][5] = [ 0,28,27, 5];

starPike[ 9]    = [];
starPike[ 9][0] = null;
starPike[ 9][1] = [ 0,30,21, 2]; 
starPike[ 9][2] = [ 0,31,32,12];
starPike[ 9][3] = [ 0,17,14, 3];
starPike[ 9][4] = [ 0,16,15, 5];
starPike[ 9][5] = [ 0,29,28, 6];
 
starPike[10]    = [];
starPike[10][0] = null;
starPike[10][1] = [ 0,31,17, 1]; 
starPike[10][2] = [ 0,32,25, 3];
starPike[10][3] = [ 0,22,19, 4];
starPike[10][4] = [ 0,21,20, 6];
starPike[10][5] = [ 0,30,29, 7];

starPike[11]    = [];
starPike[11][0] = null;
starPike[11][1] = [ 0,32,22, 2]; 
starPike[11][2] = [ 0,25,24, 4];
starPike[11][3] = [ 0,14,13, 5];
starPike[11][4] = [ 0,17,16, 7];
starPike[11][5] = [ 0,31,30, 8];

starPike[12]    = [];
starPike[12][0] = null;
starPike[12][1] = [ 0,25,14, 1]; 
starPike[12][2] = [ 0,24,23, 5];
starPike[12][3] = [ 0,19,18, 6];
starPike[12][4] = [ 0,22,21, 8];
starPike[12][5] = [ 0,32,31, 9];
        
///////////////   Синие   /////////////
starPike[13]    = [];
starPike[13][0] = null;
starPike[13][1] = [ 0, 1]; 
starPike[13][2] = [ 0,14,11];
starPike[13][3] = [ 0, 3];
starPike[13][4] = [ 0,23, 4];
starPike[13][5] = [ 0, 5];
starPike[13][6] = [ 0,15, 7];

starPike[14]    = [];
starPike[14][0] = null;
starPike[14][1] = [ 0, 1]; 
starPike[14][2] = [ 0,17, 9];
starPike[14][3] = [ 0,11];
starPike[14][4] = [ 0,25,12];
starPike[14][5] = [ 0, 3];
starPike[14][6] = [ 0,13, 5];

starPike[15]    = [];
starPike[15][0] = null;
starPike[15][1] = [ 0, 1]; 
starPike[15][2] = [ 0,13, 3];
starPike[15][3] = [ 0, 5];
starPike[15][4] = [ 0,27, 6];
starPike[15][5] = [ 0, 7];
starPike[15][6] = [ 0,16, 9];

starPike[16]    = [];
starPike[16][0] = null;
starPike[16][1] = [ 0, 1]; 
starPike[16][2] = [ 0,15, 5];
starPike[16][3] = [ 0, 7];
starPike[16][4] = [ 0,29, 8];
starPike[16][5] = [ 0, 9];
starPike[16][6] = [ 0,17,11]; 
    
starPike[17]    = [];
starPike[17][0] = null;
starPike[17][1] = [ 0, 1]; 
starPike[17][2] = [ 0,16, 7];
starPike[17][3] = [ 0, 9];
starPike[17][4] = [ 0,31,10];
starPike[17][5] = [ 0,11];
starPike[17][6] = [ 0,14, 3]; 

starPike[18]    = [];
starPike[18][0] = null;
starPike[18][1] = [ 0, 2]; 
starPike[18][2] = [ 0,20, 8];
starPike[18][3] = [ 0, 6];
starPike[18][4] = [ 0,26, 5];
starPike[18][5] = [ 0, 4];
starPike[18][6] = [ 0,19,12]; 

starPike[19]    = [];
starPike[19][0] = null;
starPike[19][1] = [ 0, 2]; 
starPike[19][2] = [ 0,18, 6];
starPike[19][3] = [ 0, 4];
starPike[19][4] = [ 0,24, 3];
starPike[19][5] = [ 0,12];
starPike[19][6] = [ 0,22,10]; 

starPike[20]    = [];
starPike[20][0] = null;
starPike[20][1] = [ 0, 2]; 
starPike[20][2] = [ 0,21,10];
starPike[20][3] = [ 0, 8];
starPike[20][4] = [ 0,28, 7];
starPike[20][5] = [ 0, 6];
starPike[20][6] = [ 0,18, 4];

starPike[21]    = [];
starPike[21][0] = null;
starPike[21][1] = [ 0, 2]; 
starPike[21][2] = [ 0,22,12];
starPike[21][3] = [ 0,10];
starPike[21][4] = [ 0,30, 9];
starPike[21][5] = [ 0, 8];
starPike[21][6] = [ 0,20, 6];

starPike[22]    = [];
starPike[22][0] = null;
starPike[22][1] = [ 0, 2]; 
starPike[22][2] = [ 0,19, 4];
starPike[22][3] = [ 0,12];
starPike[22][4] = [ 0,32,11];
starPike[22][5] = [ 0,10];
starPike[22][6] = [ 0,21, 8];

starPike[23]    = [];
starPike[23][0] = null;
starPike[23][1] = [ 0, 3]; 
starPike[23][2] = [ 0,24,12];
starPike[23][3] = [ 0, 4];
starPike[23][4] = [ 0,26, 6];
starPike[23][5] = [ 0, 5];
starPike[23][6] = [ 0,13, 1];

starPike[24]    = [];
starPike[24][0] = null;
starPike[24][1] = [ 0, 3]; 
starPike[24][2] = [ 0,25,11];
starPike[24][3] = [ 0,12];
starPike[24][4] = [ 0,19, 2];
starPike[24][5] = [ 0, 4];
starPike[24][6] = [ 0,23, 5];
    
starPike[25]    = [];
starPike[25][0] = null;
starPike[25][1] = [ 0, 3]; 
starPike[25][2] = [ 0,14, 1];
starPike[25][3] = [ 0,11];
starPike[25][4] = [ 0,32,10];
starPike[25][5] = [ 0,12];
starPike[25][6] = [ 0,24, 4];

starPike[26]    = [];
starPike[26][0] = null;
starPike[26][1] = [ 0, 4]; 
starPike[26][2] = [ 0,18, 2];
starPike[26][3] = [ 0, 6];
starPike[26][4] = [ 0,27, 7];
starPike[26][5] = [ 0, 5];
starPike[26][6] = [ 0,23, 3];

starPike[27]    = [];
starPike[27][0] = null;
starPike[27][1] = [ 0, 5]; 
starPike[27][2] = [ 0,26, 4];
starPike[27][3] = [ 0, 6];
starPike[27][4] = [ 0,28, 8];
starPike[27][5] = [ 0, 7];
starPike[27][6] = [ 0,15, 1];
    
starPike[28]    = [];
starPike[28][0] = null;
starPike[28][1] = [ 0, 6]; 
starPike[28][2] = [ 0,20, 2];
starPike[28][3] = [ 0, 8];
starPike[28][4] = [ 0,29, 9];
starPike[28][5] = [ 0, 7];
starPike[28][6] = [ 0,27, 5];
    
starPike[29]    = [];
starPike[29][0] = null;
starPike[29][1] = [ 0, 7]; 
starPike[29][2] = [ 0,28, 6];
starPike[29][3] = [ 0, 8];
starPike[29][4] = [ 0,30,10];
starPike[29][5] = [ 0, 9];
starPike[29][6] = [ 0,16, 1];
    
starPike[30]    = [];
starPike[30][0] = null;
starPike[30][1] = [ 0, 8]; 
starPike[30][2] = [ 0,21, 2];
starPike[30][3] = [ 0,10];
starPike[30][4] = [ 0,31,11];
starPike[30][5] = [ 0, 9];
starPike[30][6] = [ 0,29, 7];
    
starPike[31]    = [];
starPike[31][0] = null;
starPike[31][1] = [ 0, 9]; 
starPike[31][2] = [ 0,30, 8];
starPike[31][3] = [ 0,10];
starPike[31][4] = [ 0,32,12];
starPike[31][5] = [ 0,11];
starPike[31][6] = [ 0,17, 1];
    
starPike[32]    = [];
starPike[32][0] = null;
starPike[32][1] = [ 0,10]; 
starPike[32][2] = [ 0,22, 2];
starPike[32][3] = [ 0,12];
starPike[32][4] = [ 0,25, 3];
starPike[32][5] = [ 0,11];
starPike[32][6] = [ 0,31, 9];
    
for (i = 33; i <= 92; i++) {
	starPike[i] = [];
	starPike[i][0] = null;
	
    starPike[i][1] = []; 
    starPike[i][2] = [];
    starPike[i][3] = [];
    starPike[i][4] = [];
    starPike[i][5] = [];
    starPike[i][6] = [];
}
	
previosStarPikePoints = [];
for (v = 1; v <= 32; v++) {
    previosStarPikePoints[v] = new Set();
    for (i = 1; i<= starPike[v].length - 1; i++) {
        for (j = 1; j <= starPike[v][i].length - 1; j++) {
            let p = starPike[v][i][j];
            previosStarPikePoints[v].add(p);
        }
    }
    if (v >= 1 && v <= 12) {
        starOfCastling[v].forEach(function(k) {
            previosStarPikePoints[v].add(k);
        });
    }
}
	
/////////// Пучки для Слонов по парам (p,v)
const beamPike = [[[[]]]];

beamPike[0] = null;

for (p = 1; p <= 92; p++) {
    
    beamPike[p] = [];
    
    for (v = 1; v <= 92; v++) {
        beamPike[p][v] = [];
    }
}

for (p = 1; p <= 32; p++) {
    
    beamPike[p] = [];
    
for (v = 1; v <= 32; v++) {
    if (previosStarPikePoints[v].has(p)) {
    
            beamPike[p][v] = [];
            beamPike[p][v][0] = null;
            
            for (i = 1; i <= starPike[v].length - 1; i++) {
                
                beamPike[p][v][i] = starPike[v][i];
                
                let exclude = false;
                for (j = 1; j <= beamPike[p][v][i].length - 1; j++) {
                    // исключение НЕПОСРЕДСТВЕННО ВХОДЯЩЕГО луча
                    if (beamPike[p][v][i][j] === p) {
                        exclude = true;
                    }
                }
                // исключение ВХОДЯЩЕГО луча
                if (exclude) {
                    beamPike[p][v][i] = null;
                }
                else {
                    beamPike[p][v][i] = starPike[v][i];
                }
            }
            beamPike[p][v] = beamPike[p][v].filter(function(element) {return element !== null});
        }
    }
    
for (v = 33; v <= 92; v++) {
        beamPike[p][v] = [];
    }
}
    
///////////////////////////////   Лодьи (Топоры)    /////////////////////////////
const starAxe = [[[]]];
starAxe[ 0] = null;
/////////////   Красные   /////////////
starAxe[ 1]    = [];                                                     
starAxe[ 1][0] = null;
starAxe[ 1][1] = [ 0,36,63, 7]; 
starAxe[ 1][2] = [ 0,34,53, 5];
starAxe[ 1][3] = [ 0,33,43, 3];
starAxe[ 1][4] = [ 0,35,83,11];
starAxe[ 1][5] = [ 0,37,73, 9];
    
starAxe[ 2]    = [];
starAxe[ 2][0] = null;
starAxe[ 2][1] = [ 0,41,68, 8]; 
starAxe[ 2][2] = [ 0,39,58, 6];
starAxe[ 2][3] = [ 0,38,48, 4];
starAxe[ 2][4] = [ 0,40,88,12];
starAxe[ 2][5] = [ 0,42,78,10];
    
starAxe[ 3]    = [];
starAxe[ 3][0] = null;
starAxe[ 3][1] = [ 0,43,33, 1]; 
starAxe[ 3][2] = [ 0,44,54, 5];
starAxe[ 3][3] = [ 0,46,51, 4];
starAxe[ 3][4] = [ 0,47,91,12];
starAxe[ 3][5] = [ 0,45,84,11];
    
starAxe[ 4]    = [];
starAxe[ 4][0] = null;
starAxe[ 4][1] = [ 0,48,38, 2]; 
starAxe[ 4][2] = [ 0,49,59, 6];
starAxe[ 4][3] = [ 0,52,56, 5];
starAxe[ 4][4] = [ 0,51,46, 3];
starAxe[ 4][5] = [ 0,50,89,12];
    
starAxe[ 5]    = [];
starAxe[ 5][0] = null;
starAxe[ 5][1] = [ 0,53,34, 1]; 
starAxe[ 5][2] = [ 0,54,44, 3];
starAxe[ 5][3] = [ 0,56,52, 4];
starAxe[ 5][4] = [ 0,57,61, 6];
starAxe[ 5][5] = [ 0,55,64, 7];
    
starAxe[ 6]    = [];
starAxe[ 6][0] = null;
starAxe[ 6][1] = [ 0,58,39, 2]; 
starAxe[ 6][2] = [ 0,59,49, 4];
starAxe[ 6][3] = [ 0,61,57, 5];
starAxe[ 6][4] = [ 0,62,66, 7];
starAxe[ 6][5] = [ 0,60,69, 8];
    
starAxe[ 7]    = [];
starAxe[ 7][0] = null;
starAxe[ 7][1] = [ 0,63,36, 1]; 
starAxe[ 7][2] = [ 0,65,74, 9];
starAxe[ 7][3] = [ 0,67,71, 8];
starAxe[ 7][4] = [ 0,66,62, 6];
starAxe[ 7][5] = [ 0,64,55, 5];
    
starAxe[ 8]    = [];
starAxe[ 8][0] = null;
starAxe[ 8][1] = [ 0,68,41, 2]; 
starAxe[ 8][2] = [ 0,69,60, 6];
starAxe[ 8][3] = [ 0,71,67, 7];
starAxe[ 8][4] = [ 0,72,76, 9];
starAxe[ 8][5] = [ 0,70,79,10];
    
starAxe[ 9]    = [];
starAxe[ 9][0] = null;
starAxe[ 9][1] = [ 0,73,37, 1]; 
starAxe[ 9][2] = [ 0,75,85,11];
starAxe[ 9][3] = [ 0,77,81,10];
starAxe[ 9][4] = [ 0,76,72, 8];
starAxe[ 9][5] = [ 0,74,65, 7];
    
starAxe[10]    = [];
starAxe[10][0] = null;
starAxe[10][1] = [ 0,78,42, 2]; 
starAxe[10][2] = [ 0,79,70, 8];
starAxe[10][3] = [ 0,81,77, 9];
starAxe[10][4] = [ 0,82,87,11];
starAxe[10][5] = [ 0,80,90,12];
    
starAxe[11]    = [];
starAxe[11][0] = null;
starAxe[11][1] = [ 0,83,35, 1]; 
starAxe[11][2] = [ 0,84,45, 3];
starAxe[11][3] = [ 0,86,92,12];
starAxe[11][4] = [ 0,87,82,10];
starAxe[11][5] = [ 0,85,75, 9];
    
starAxe[12]    = [];
starAxe[12][0] = null;
starAxe[12][1] = [ 0,88,40, 2];
starAxe[12][2] = [ 0,90,80,10];
starAxe[12][3] = [ 0,92,86,11];
starAxe[12][4] = [ 0,91,47, 3];
starAxe[12][5] = [ 0,89,50, 4];
    
/////////////  Синие   /////////////
starAxe[13]    = [];                                                     
starAxe[13][0] = null;
starAxe[13][1] = [ 0,54,56,26,59,58]; 
starAxe[13][2] = [ 0,33,35,17,75,77]; 
starAxe[13][3] = [ 0,44,46,24,89,88];
starAxe[13][4] = [ 0,34,36,16,74,76];
starAxe[13][5] = [ 0,53,55,27,62,60];
starAxe[13][6] = [ 0,43,45,25,92,90];
  
starAxe[14]    = [];                                                     
starAxe[14][0] = null;
starAxe[14][1] = [ 0,84,86,32,80,78]; 
starAxe[14][2] = [ 0,33,34,15,64,66]; 
starAxe[14][3] = [ 0,43,44,23,52,49];
starAxe[14][4] = [ 0,83,85,31,81,79];
starAxe[14][5] = [ 0,45,47,24,50,48];
starAxe[14][6] = [ 0,35,37,16,65,67];
    
starAxe[15]    = [];                                                     
starAxe[15][0] = null;
starAxe[15][1] = [ 0,55,57,26,49,48]; 
starAxe[15][2] = [ 0,36,37,17,85,87]; 
starAxe[15][3] = [ 0,53,54,23,51,50];
starAxe[15][4] = [ 0,63,65,29,72,70];
starAxe[15][5] = [ 0,34,33,14,84,86];
starAxe[15][6] = [ 0,64,66,28,69,68]; 
    
starAxe[16]    = [];                                                     
starAxe[16][0] = null;
starAxe[16][1] = [ 0,74,76,30,79,78]; 
starAxe[16][2] = [ 0,36,34,13,44,46]; 
starAxe[16][3] = [ 0,65,67,28,60,58];
starAxe[16][4] = [ 0,37,35,14,45,47];
starAxe[16][5] = [ 0,63,64,27,61,59];
starAxe[16][6] = [ 0,73,75,31,82,80];
    
starAxe[17]    = [];                                                     
starAxe[17][0] = null;
starAxe[17][1] = [ 0,85,87,32,90,88]; 
starAxe[17][2] = [ 0,37,36,15,55,57]; 
starAxe[17][3] = [ 0,75,77,30,70,68];
starAxe[17][4] = [ 0,35,33,13,54,56];
starAxe[17][5] = [ 0,73,74,29,71,69];
starAxe[17][6] = [ 0,83,84,25,91,89]; 
    
starAxe[18]    = [];                                                     
starAxe[18][0] = null;
starAxe[18][1] = [ 0,38,40,22,80,82]; 
starAxe[18][2] = [ 0,59,61,27,64,63]; 
starAxe[18][3] = [ 0,48,50,24,47,45];
starAxe[18][4] = [ 0,58,60,28,67,65];
starAxe[18][5] = [ 0,49,52,23,44,43];
starAxe[18][6] = [ 0,39,41,21,79,81];
    
starAxe[19]    = [];                                                     
starAxe[19][0] = null;
starAxe[19][1] = [ 0,40,42,21,70,72]; 
starAxe[19][2] = [ 0,50,51,23,54,53]; 
starAxe[19][3] = [ 0,88,90,32,87,85];
starAxe[19][4] = [ 0,48,49,26,57,55];
starAxe[19][5] = [ 0,38,39,20,69,71];
starAxe[19][6] = [ 0,89,91,25,84,83]; 
    
starAxe[20]    = [];                                                     
starAxe[20][0] = null;
starAxe[20][1] = [ 0,39,38,19,89,91]; 
starAxe[20][2] = [ 0,69,71,29,74,73]; 
starAxe[20][3] = [ 0,58,59,26,56,54];
starAxe[20][4] = [ 0,68,70,30,77,75];
starAxe[20][5] = [ 0,60,62,27,55,53];
starAxe[20][6] = [ 0,41,42,22,90,92]; 
    
starAxe[21]    = [];                                                     
starAxe[21][0] = null;
starAxe[21][1] = [ 0,41,39,18,49,52]; 
starAxe[21][2] = [ 0,79,81,31,85,83]; 
starAxe[21][3] = [ 0,68,69,28,66,64]; 
starAxe[21][4] = [ 0,78,80,32,86,84]; 
starAxe[21][5] = [ 0,70,72,29,65,63]; 
starAxe[21][6] = [ 0,42,40,19,50,51]; 
    
starAxe[22]    = [];                                                     
starAxe[22][0] = null;
starAxe[22][1] = [ 0,42,41,20,60,62]; 
starAxe[22][2] = [ 0,90,92,25,45,43]; 
starAxe[22][3] = [ 0,78,79,30,76,74]; 
starAxe[22][4] = [ 0,88,89,24,46,44]; 
starAxe[22][5] = [ 0,80,82,31,75,73]; 
starAxe[22][6] = [ 0,40,38,18,59,61]; 
    
starAxe[23]    = [];                                                     
starAxe[23][0] = null;
starAxe[23][1] = [ 0,51,50,19,40,42]; 
starAxe[23][2] = [ 0,54,53,15,63,65]; 
starAxe[23][3] = [ 0,46,47,25,86,87]; 
starAxe[23][4] = [ 0,56,57,27,66,67]; 
starAxe[23][5] = [ 0,44,43,14,83,85]; 
starAxe[23][6] = [ 0,52,49,18,39,41]; 
    
starAxe[24]    = [];                                                     
starAxe[24][0] = null;
starAxe[24][1] = [ 0,89,88,22,78,79]; 
starAxe[24][2] = [ 0,46,44,13,34,36]; 
starAxe[24][3] = [ 0,91,92,32,82,81]; 
starAxe[24][4] = [ 0,51,52,26,61,62]; 
starAxe[24][5] = [ 0,47,45,14,35,37]; 
starAxe[24][6] = [ 0,50,48,18,58,60]; 
    
starAxe[25]    = [];                                                     
starAxe[25][0] = null;
starAxe[25][1] = [ 0,92,90,22,42,41]; 
starAxe[25][2] = [ 0,45,43,13,53,55]; 
starAxe[25][3] = [ 0,86,87,31,77,76]; 
starAxe[25][4] = [ 0,47,46,23,56,57]; 
starAxe[25][5] = [ 0,84,83,17,73,74]; 
starAxe[25][6] = [ 0,91,89,19,38,39]; 
    
starAxe[26]    = [];                                                     
starAxe[26][0] = null;
starAxe[26][1] = [ 0,49,48,19,88,90]; 
starAxe[26][2] = [ 0,57,55,15,36,37]; 
starAxe[26][3] = [ 0,52,51,24,91,92]; 
starAxe[26][4] = [ 0,61,62,28,71,72]; 
starAxe[26][5] = [ 0,56,54,13,33,35]; 
starAxe[26][6] = [ 0,59,58,20,68,70]; 
    
starAxe[27]    = [];                                                     
starAxe[27][0] = null;
starAxe[27][1] = [ 0,61,59,18,38,40];  
starAxe[27][2] = [ 0,64,63,16,73,75];  
starAxe[27][3] = [ 0,57,56,23,46,47];
starAxe[27][4] = [ 0,66,67,29,76,77]; 
starAxe[27][5] = [ 0,55,53,13,43,45]; 
starAxe[27][6] = [ 0,62,60,20,41,42];  
    
starAxe[28]    = [];                                                     
starAxe[28][0] = null;
starAxe[28][1] = [ 0,60,58,18,48,50];
starAxe[28][2] = [ 0,67,65,16,37,35];
starAxe[28][3] = [ 0,62,61,26,52,51];
starAxe[28][4] = [ 0,71,72,30,81,82];
starAxe[28][5] = [ 0,66,64,15,34,33];
starAxe[28][6] = [ 0,69,68,21,78,80];
    
starAxe[29]    = [];                                                     
starAxe[29][0] = null;
starAxe[29][1] = [ 0,71,69,20,39,38]; 
starAxe[29][2] = [ 0,74,73,17,83,84]; 
starAxe[29][3] = [ 0,67,66,27,57,56]; 
starAxe[29][4] = [ 0,76,77,31,87,86]; 
starAxe[29][5] = [ 0,65,63,15,53,54]; 
starAxe[29][6] = [ 0,72,70,21,42,40]; 
    
starAxe[30]    = [];                                                     
starAxe[30][0] = null;
starAxe[30][1] = [ 0,70,68,20,58,59]; 
starAxe[30][2] = [ 0,77,75,17,35,33]; 
starAxe[30][3] = [ 0,72,71,28,62,61]; 
starAxe[30][4] = [ 0,81,82,32,92,91]; 
starAxe[30][5] = [ 0,76,74,16,36,34]; 
starAxe[30][6] = [ 0,79,78,22,88,89];
    
starAxe[31]    = [];                                                     
starAxe[31][0] = null;
starAxe[31][1] = [ 0,81,79,21,41,39]; 
starAxe[31][2] = [ 0,85,83,14,43,44]; 
starAxe[31][3] = [ 0,77,76,29,67,66]; 
starAxe[31][4] = [ 0,87,86,25,47,46]; 
starAxe[31][5] = [ 0,75,73,16,63,64]; 
starAxe[31][6] = [ 0,82,80,22,40,38];
    
starAxe[32]    = [];                                                     
starAxe[32][0] = null;
starAxe[32][1] = [ 0,80,78,21,68,69]; 
starAxe[32][2] = [ 0,86,84,14,33,34]; 
starAxe[32][3] = [ 0,82,81,30,72,71]; 
starAxe[32][4] = [ 0,92,91,24,51,52]; 
starAxe[32][5] = [ 0,87,85,17,37,36]; 
starAxe[32][6] = [ 0,90,88,19,48,49];
    
/////////////   Зелёные   /////////////
starAxe[33]    = [];                                                     
starAxe[33][0] = null;
starAxe[33][1] = [ 0, 1]; 
starAxe[33][2] = [ 0,43, 3]; 
starAxe[33][3] = [ 0,14,84,86,32,80,78,21];
starAxe[33][4] = [ 0,34,15,64,66,28,69];
starAxe[33][5] = [ 0,13,54,56,26,59,58,20];
starAxe[33][6] = [ 0,35,17,75,77,30,70];

starAxe[34]    = [];                                                     
starAxe[34][0] = null;
starAxe[34][1] = [ 0, 1]; 
starAxe[34][2] = [ 0,53, 5]; 
starAxe[34][3] = [ 0,15,64,66,28,69,68,21];
starAxe[34][4] = [ 0,33,14,84,86,32,80];
starAxe[34][5] = [ 0,13,44,46,24,89,88,22];
starAxe[34][6] = [ 0,36,16,74,76,30,79];

starAxe[35]    = [];                                                     
starAxe[35][0] = null;
starAxe[35][1] = [ 0, 1]; 
starAxe[35][2] = [ 0,83,11]; 
starAxe[35][3] = [ 0,14,45,47,24,50,48,18];
starAxe[35][4] = [ 0,37,16,65,67,28,60];
starAxe[35][5] = [ 0,17,75,77,30,70,68,20];
starAxe[35][6] = [ 0,33,13,54,56,26,59];

starAxe[36]    = [];                                                     
starAxe[36][0] = null;
starAxe[36][1] = [ 0, 1]; 
starAxe[36][2] = [ 0,63, 7]; 
starAxe[36][3] = [ 0,16,74,76,30,79,78,22];
starAxe[36][4] = [ 0,34,13,44,46,24,89];
starAxe[36][5] = [ 0,15,55,57,26,49,48,19];
starAxe[36][6] = [ 0,37,17,85,87,32,90];

starAxe[37]    = [];                                                     
starAxe[37][0] = null;
starAxe[37][1] = [ 0, 1]; 
starAxe[37][2] = [ 0,73, 9]; 
starAxe[37][3] = [ 0,16,65,67,28,60,58,18];
starAxe[37][4] = [ 0,35,14,45,47,24,50];
starAxe[37][5] = [ 0,17,85,87,32,90,88,19];
starAxe[37][6] = [ 0,36,15,55,57,26,49];

starAxe[38]    = [];                                                     
starAxe[38][0] = null;
starAxe[38][1] = [ 0, 2]; 
starAxe[38][2] = [ 0,48, 4]; 
starAxe[38][3] = [ 0,19,89,91,25,84,83,17];
starAxe[38][4] = [ 0,39,20,69,71,29,74];
starAxe[38][5] = [ 0,18,59,61,27,64,63,16];
starAxe[38][6] = [ 0,40,22,80,82,31,75];

starAxe[39]    = [];                                                     
starAxe[39][0] = null;
starAxe[39][1] = [ 0, 2]; 
starAxe[39][2] = [ 0,58, 6]; 
starAxe[39][3] = [ 0,18,49,52,23,44,43,14];
starAxe[39][4] = [ 0,41,21,79,81,31,85];
starAxe[39][5] = [ 0,20,69,71,29,74,73,17];
starAxe[39][6] = [ 0,38,19,89,91,25,84];

starAxe[40]    = [];                                                     
starAxe[40][0] = null;
starAxe[40][1] = [ 0, 2]; 
starAxe[40][2] = [ 0,88,12]; 
starAxe[40][3] = [ 0,22,80,82,31,75,73,16];
starAxe[40][4] = [ 0,38,18,59,61,27,64];
starAxe[40][5] = [ 0,19,50,51,23,54,53,15];
starAxe[40][6] = [ 0,42,21,70,72,29,65];

starAxe[41]    = [];                                                     
starAxe[41][0] = null;
starAxe[41][1] = [ 0, 2]; 
starAxe[41][2] = [ 0,68, 8]; 
starAxe[41][3] = [ 0,20,60,62,27,55,53,13];
starAxe[41][4] = [ 0,42,22,90,92,25,45];
starAxe[41][5] = [ 0,21,79,81,31,85,83,14];
starAxe[41][6] = [ 0,39,18,49,52,23,44];

starAxe[42]    = [];                                                     
starAxe[42][0] = null;
starAxe[42][1] = [ 0, 2]; 
starAxe[42][2] = [ 0,78,10]; 
starAxe[42][3] = [ 0,21,70,72,29,65,63,15];
starAxe[42][4] = [ 0,40,19,50,51,23,54];
starAxe[42][5] = [ 0,22,90,92,25,45,43,13];
starAxe[42][6] = [ 0,41,20,60,62,27,55];

starAxe[43]    = [];                                                     
starAxe[43][0] = null;
starAxe[43][1] = [ 0, 3]; 
starAxe[43][2] = [ 0,33, 1]; 
starAxe[43][3] = [ 0,14,83,85,31,81,79,21];
starAxe[43][4] = [ 0,44,23,52,49,18,39];
starAxe[43][5] = [ 0,13,53,55,27,62,60,20];
starAxe[43][6] = [ 0,45,25,92,90,22,42];

starAxe[44]    = [];                                                     
starAxe[44][0] = null;
starAxe[44][1] = [ 0, 3]; 
starAxe[44][2] = [ 0,54, 5]; 
starAxe[44][3] = [ 0,43,14,83,85,31,81];
starAxe[44][4] = [ 0,23,52,49,18,39,41,21];
starAxe[44][5] = [ 0,46,24,89,88,22,78];
starAxe[44][6] = [ 0,13,34,36,16,74,76,30];

starAxe[45]    = [];                                                     
starAxe[45][0] = null;
starAxe[45][1] = [ 0, 3]; 
starAxe[45][2] = [ 0,84,11]; 
starAxe[45][3] = [ 0,25,92,90,22,42,41,20];
starAxe[45][4] = [ 0,43,13,53,55,27,62];
starAxe[45][5] = [ 0,14,35,37,16,65,67,28];
starAxe[45][6] = [ 0,47,24,50,48,18,58];

starAxe[46]    = [];                                                     
starAxe[46][0] = null;
starAxe[46][1] = [ 0, 3]; 
starAxe[46][2] = [ 0,51, 4]; 
starAxe[46][3] = [ 0,24,89,88,22,78,79,30];
starAxe[46][4] = [ 0,44,13,34,36,16,74];
starAxe[46][5] = [ 0,47,25,86,87,31,77];
starAxe[46][6] = [ 0,23,56,57,27,66,67,29];

starAxe[47]    = [];                                                     
starAxe[47][0] = null;
starAxe[47][1] = [ 0, 3]; 
starAxe[47][2] = [ 0,91,12]; 
starAxe[47][3] = [ 0,25,86,87,31,77,76,29];
starAxe[47][4] = [ 0,46,23,56,57,27,66];
starAxe[47][5] = [ 0,24,50,48,18,58,60,28];
starAxe[47][6] = [ 0,45,14,35,37,16,65];

starAxe[48]    = [];                                                     
starAxe[48][0] = null;
starAxe[48][1] = [ 0, 4]; 
starAxe[48][2] = [ 0,38, 2]; 
starAxe[48][3] = [ 0,19,88,90,32,87,85,17];
starAxe[48][4] = [ 0,49,26,57,55,15,36];
starAxe[48][5] = [ 0,18,58,60,28,67,65,16];
starAxe[48][6] = [ 0,50,24,47,45,14,35];

starAxe[49]    = [];                                                     
starAxe[49][0] = null;
starAxe[49][1] = [ 0, 4]; 
starAxe[49][2] = [ 0,59, 6]; 
starAxe[49][3] = [ 0,18,39,41,21,79,81,31];
starAxe[49][4] = [ 0,52,23,44,43,14,83];
starAxe[49][5] = [ 0,26,57,55,15,36,37,17];
starAxe[49][6] = [ 0,48,19,88,90,32,87];

starAxe[50]    = [];                                                     
starAxe[50][0] = null;
starAxe[50][1] = [ 0, 4]; 
starAxe[50][2] = [ 0,89,12]; 
starAxe[50][3] = [ 0,19,40,42,21,70,72,29];
starAxe[50][4] = [ 0,51,23,54,53,15,63];
starAxe[50][5] = [ 0,24,47,45,14,35,37,16];
starAxe[50][6] = [ 0,48,18,58,60,28,67];

starAxe[51]    = [];                                                     
starAxe[51][0] = null;
starAxe[51][1] = [ 0, 4]; 
starAxe[51][2] = [ 0,46, 3]; 
starAxe[51][3] = [ 0,50,19,40,42,21,70];
starAxe[51][4] = [ 0,23,54,53,15,63,65,29];
starAxe[51][5] = [ 0,24,91,92,32,82,81,30];
starAxe[51][6] = [ 0,52,26,61,62,28,71];

starAxe[52]    = [];                                                     
starAxe[52][0] = null;
starAxe[52][1] = [ 0, 4]; 
starAxe[52][2] = [ 0,56, 5]; 
starAxe[52][3] = [ 0,23,44,43,14,83,85,31];
starAxe[52][4] = [ 0,49,18,39,41,21,79];
starAxe[52][5] = [ 0,26,61,62,28,71,72,30];
starAxe[52][6] = [ 0,51,24,91,92,32,82];

starAxe[53]    = [];                                                     
starAxe[53][0] = null;
starAxe[53][1] = [ 0, 5]; 
starAxe[53][2] = [ 0,34, 1]; 
starAxe[53][3] = [ 0,15,63,65,29,72,70,21];
starAxe[53][4] = [ 0,54,23,51,50,19,40];
starAxe[53][5] = [ 0,13,43,45,25,92,90,22];
starAxe[53][6] = [ 0,55,27,62,60,20,41];

starAxe[54]    = [];                                                     
starAxe[54][0] = null;
starAxe[54][1] = [ 0, 5]; 
starAxe[54][2] = [ 0,44, 3]; 
starAxe[54][3] = [ 0,23,51,50,19,40,42,21];
starAxe[54][4] = [ 0,53,15,63,65,29,72];
starAxe[54][5] = [ 0,13,33,35,17,75,77,30];
starAxe[54][6] = [ 0,56,26,59,58,20,68];

starAxe[55]    = [];                                                     
starAxe[55][0] = null;
starAxe[55][1] = [ 0, 5]; 
starAxe[55][2] = [ 0,64, 7]; 
starAxe[55][3] = [ 0,27,62,60,20,41,42,22];
starAxe[55][4] = [ 0,53,13,43,45,25,92];
starAxe[55][5] = [ 0,15,36,37,17,85,87,32];
starAxe[55][6] = [ 0,57,26,49,48,19,88];

starAxe[56]    = [];                                                     
starAxe[56][0] = null;
starAxe[56][1] = [ 0, 5]; 
starAxe[56][2] = [ 0,52, 4]; 
starAxe[56][3] = [ 0,23,46,47,25,86,87,31];
starAxe[56][4] = [ 0,57,27,66,67,29,76];
starAxe[56][5] = [ 0,26,59,58,20,68,70,30];
starAxe[56][6] = [ 0,54,13,33,35,17,75];

starAxe[57]    = [];                                                     
starAxe[57][0] = null;
starAxe[57][1] = [ 0, 5]; 
starAxe[57][2] = [ 0,61, 6]; 
starAxe[57][3] = [ 0,26,49,48,19,88,90,32];
starAxe[57][4] = [ 0,55,15,36,37,17,85];
starAxe[57][5] = [ 0,27,66,67,29,76,77,31];
starAxe[57][6] = [ 0,56,23,46,47,25,86];

starAxe[58]    = [];                                                     
starAxe[58][0] = null;
starAxe[58][1] = [ 0, 6]; 
starAxe[58][2] = [ 0,39, 2]; 
starAxe[58][3] = [ 0,18,48,50,24,47,45,14];
starAxe[58][4] = [ 0,60,28,67,65,16,37];
starAxe[58][5] = [ 0,20,68,70,30,77,75,17];
starAxe[58][6] = [ 0,59,26,56,54,13,33];

starAxe[59]    = [];                                                     
starAxe[59][0] = null;
starAxe[59][1] = [ 0, 6]; 
starAxe[59][2] = [ 0,49, 4]; 
starAxe[59][3] = [ 0,18,38,40,22,80,82,31];
starAxe[59][4] = [ 0,61,27,64,63,16,73];
starAxe[59][5] = [ 0,26,56,54,13,33,35,17];
starAxe[59][6] = [ 0,58,20,68,70,30,77];

starAxe[60]    = [];                                                     
starAxe[60][0] = null;
starAxe[60][1] = [ 0, 6]; 
starAxe[60][2] = [ 0,69, 8]; 
starAxe[60][3] = [ 0,20,41,42,22,90,92,25];
starAxe[60][4] = [ 0,62,27,55,53,13,43];
starAxe[60][5] = [ 0,28,67,65,16,37,35,14];
starAxe[60][6] = [ 0,58,18,48,50,24,47];    

starAxe[61]    = [];                                                     
starAxe[61][0] = null;
starAxe[61][1] = [ 0, 6]; 
starAxe[61][2] = [ 0,57, 5]; 
starAxe[61][3] = [ 0,26,52,51,24,91,92,32];
starAxe[61][4] = [ 0,62,28,71,72,30,81];
starAxe[61][5] = [ 0,27,64,63,16,73,75,31];
starAxe[61][6] = [ 0,59,18,38,40,22,80];

starAxe[62]    = [];                                                     
starAxe[62][0] = null;
starAxe[62][1] = [ 0, 6]; 
starAxe[62][2] = [ 0,66, 7]; 
starAxe[62][3] = [ 0,27,55,53,13,43,45,25];
starAxe[62][4] = [ 0,60,20,41,42,22,90];
starAxe[62][5] = [ 0,28,71,72,30,81,82,32];
starAxe[62][6] = [ 0,61,26,52,51,24,91];

starAxe[63]    = [];                                                     
starAxe[63][0] = null;
starAxe[63][1] = [ 0, 7]; 
starAxe[63][2] = [ 0,36, 1]; 
starAxe[63][3] = [ 0,15,53,54,23,51,50,19];
starAxe[63][4] = [ 0,65,29,72,70,21,42];
starAxe[63][5] = [ 0,16,73,75,31,82,80,22];
starAxe[63][6] = [ 0,64,27,61,59,18,38];

starAxe[64]    = [];                                                     
starAxe[64][0] = null;
starAxe[64][1] = [ 0, 7]; 
starAxe[64][2] = [ 0,55, 5]; 
starAxe[64][3] = [ 0,27,61,59,18,38,40,22];
starAxe[64][4] = [ 0,63,16,73,75,31,82];
starAxe[64][5] = [ 0,15,34,33,14,84,86,32];
starAxe[64][6] = [ 0,66,28,69,68,21,78];

starAxe[65]    = [];                                                     
starAxe[65][0] = null;
starAxe[65][1] = [ 0, 7]; 
starAxe[65][2] = [ 0,74, 9]; 
starAxe[65][3] = [ 0,29,72,70,21,42,40,19];
starAxe[65][4] = [ 0,63,15,53,54,23,51];
starAxe[65][5] = [ 0,16,37,35,14,45,47,24];
starAxe[65][6] = [ 0,67,28,60,58,18,48];

starAxe[66]    = [];                                                     
starAxe[66][0] = null;
starAxe[66][1] = [ 0, 7]; 
starAxe[66][2] = [ 0,62, 6]; 
starAxe[66][3] = [ 0,27,57,56,23,46,47,25];
starAxe[66][4] = [ 0,67,29,76,77,31,87];
starAxe[66][5] = [ 0,28,69,68,21,78,80,32];
starAxe[66][6] = [ 0,64,15,34,33,14,84]; 
   
starAxe[67]    = [];                                                     
starAxe[67][0] = null;
starAxe[67][1] = [ 0, 7]; 
starAxe[67][2] = [ 0,71, 8]; 
starAxe[67][3] = [ 0,28,60,58,18,48,50,24];
starAxe[67][4] = [ 0,65,16,37,35,14,45];
starAxe[67][5] = [ 0,29,76,77,31,87,86,25];
starAxe[67][6] = [ 0,66,27,57,56,23,46];

starAxe[68]    = [];                                                     
starAxe[68][0] = null;
starAxe[68][1] = [ 0, 8]; 
starAxe[68][2] = [ 0,41, 2]; 
starAxe[68][3] = [ 0,20,58,59,26,56,54,13];
starAxe[68][4] = [ 0,70,30,77,75,17,35];
starAxe[68][5] = [ 0,21,78,80,32,86,84,14];
starAxe[68][6] = [ 0,69,28,66,64,15,34];

starAxe[69]    = [];                                                     
starAxe[69][0] = null;
starAxe[69][1] = [ 0, 8]; 
starAxe[69][2] = [ 0,60, 6]; 
starAxe[69][3] = [ 0,20,39,38,19,89,91,25];
starAxe[69][4] = [ 0,71,29,74,73,17,83];
starAxe[69][5] = [ 0,28,66,64,15,34,33,14];
starAxe[69][6] = [ 0,68,21,78,80,32,86];

starAxe[70]    = [];                                                     
starAxe[70][0] = null;
starAxe[70][1] = [ 0, 8]; 
starAxe[70][2] = [ 0,79,10]; 
starAxe[70][3] = [ 0,21,42,40,19,50,51,23];
starAxe[70][4] = [ 0,72,29,65,63,15,53];
starAxe[70][5] = [ 0,30,77,75,17,35,33,13];
starAxe[70][6] = [ 0,68,20,58,59,26,56];    
   
starAxe[71]    = [];                                                     
starAxe[71][0] = null;
starAxe[71][1] = [ 0, 8]; 
starAxe[71][2] = [ 0,67, 7]; 
starAxe[71][3] = [ 0,28,62,61,26,52,51,24];
starAxe[71][4] = [ 0,72,30,81,82,32,92];
starAxe[71][5] = [ 0,29,74,73,17,83,84,25];
starAxe[71][6] = [ 0,69,20,39,38,19,89];

starAxe[72]    = [];                                                     
starAxe[72][0] = null;
starAxe[72][1] = [ 0, 8]; 
starAxe[72][2] = [ 0,76, 9]; 
starAxe[72][3] = [ 0,30,81,82,32,92,91,24];
starAxe[72][4] = [ 0,71,28,62,61,26,52];
starAxe[72][5] = [ 0,29,65,63,15,53,54,23];
starAxe[72][6] = [ 0,70,21,42,40,19,50];

starAxe[73]    = [];                                                     
starAxe[73][0] = null;
starAxe[73][1] = [ 0, 9]; 
starAxe[73][2] = [ 0,37, 1]; 
starAxe[73][3] = [ 0,16,63,64,27,61,59,18];
starAxe[73][4] = [ 0,75,31,82,80,22,40];
starAxe[73][5] = [ 0,17,83,84,25,91,89,19];
starAxe[73][6] = [ 0,74,29,71,69,20,39];
   
starAxe[74]    = [];                                                     
starAxe[74][0] = null;
starAxe[74][1] = [ 0, 9]; 
starAxe[74][2] = [ 0,65, 7]; 
starAxe[74][3] = [ 0,29,71,69,20,39,38,19];
starAxe[74][4] = [ 0,73,17,83,84,25,91];
starAxe[74][5] = [ 0,16,36,34,13,44,46,24];
starAxe[74][6] = [ 0,76,30,79,78,22,88];
    
starAxe[75]    = [];                                                     
starAxe[75][0] = null;
starAxe[75][1] = [ 0, 9]; 
starAxe[75][2] = [ 0,85,11]; 
starAxe[75][3] = [ 0,31,82,80,22,40,38,18];
starAxe[75][4] = [ 0,73,16,63,64,27,61];
starAxe[75][5] = [ 0,17,35,33,13,54,56,26];
starAxe[75][6] = [ 0,77,30,70,68,20,58];

starAxe[76]    = [];                                                     
starAxe[76][0] = null;
starAxe[76][1] = [ 0, 9]; 
starAxe[76][2] = [ 0,72, 8]; 
starAxe[76][3] = [ 0,30,79,78,22,88,89,24];
starAxe[76][4] = [ 0,74,16,36,34,13,44];
starAxe[76][5] = [ 0,29,67,66,27,57,56,23];
starAxe[76][6] = [ 0,77,31,87,86,25,47];

starAxe[77]    = [];                                                     
starAxe[77][0] = null;
starAxe[77][1] = [ 0, 9]; 
starAxe[77][2] = [ 0,81,10]; 
starAxe[77][3] = [ 0,30,70,68,20,58,59,26];
starAxe[77][4] = [ 0,75,17,35,33,13,54];
starAxe[77][5] = [ 0,31,87,86,25,47,46,23];
starAxe[77][6] = [ 0,76,29,67,66,27,57];

starAxe[78]    = [];                                                     
starAxe[78][0] = null;
starAxe[78][1] = [ 0,10]; 
starAxe[78][2] = [ 0,42, 2]; 
starAxe[78][3] = [ 0,21,68,69,28,66,64,15];
starAxe[78][4] = [ 0,80,32,86,84,14,33];
starAxe[78][5] = [ 0,22,88,89,24,46,44,13];
starAxe[78][6] = [ 0,79,30,76,74,16,36];

starAxe[79]    = [];                                                     
starAxe[79][0] = null;
starAxe[79][1] = [ 0,10]; 
starAxe[79][2] = [ 0,70, 8]; 
starAxe[79][3] = [ 0,21,41,39,18,49,52,23];
starAxe[79][4] = [ 0,81,31,85,83,14,43];
starAxe[79][5] = [ 0,30,76,74,16,36,34,13];
starAxe[79][6] = [ 0,78,22,88,89,24,46];

starAxe[80]    = [];                                                     
starAxe[80][0] = null;
starAxe[80][1] = [ 0,10]; 
starAxe[80][2] = [ 0,90,12]; 
starAxe[80][3] = [ 0,22,40,38,18,59,61,27];
starAxe[80][4] = [ 0,82,31,75,73,16,63];
starAxe[80][5] = [ 0,32,86,84,14,33,34,15];
starAxe[80][6] = [ 0,78,21,68,69,28,66];

starAxe[81]    = [];                                                     
starAxe[81][0] = null;
starAxe[81][1] = [ 0,10]; 
starAxe[81][2] = [ 0,77, 9]; 
starAxe[81][3] = [ 0,31,85,83,14,43,44,23];
starAxe[81][4] = [ 0,79,21,41,39,18,49];
starAxe[81][5] = [ 0,30,72,71,28,62,61,26];
starAxe[81][6] = [ 0,82,32,92,91,24,51];

starAxe[82]    = [];                                                     
starAxe[82][0] = null;
starAxe[82][1] = [ 0,10]; 
starAxe[82][2] = [ 0,87,11]; 
starAxe[82][3] = [ 0,31,75,73,16,63,64,27];
starAxe[82][4] = [ 0,80,22,40,38,18,59];
starAxe[82][5] = [ 0,32,92,91,24,51,52,26,];
starAxe[82][6] = [ 0,81,30,72,71,28,62];

starAxe[83]    = [];                                                     
starAxe[83][0] = null;
starAxe[83][1] = [ 0,11]; 
starAxe[83][2] = [ 0,35, 1]; 
starAxe[83][3] = [ 0,17,73,74,29,71,69,20];
starAxe[83][4] = [ 0,84,25,91,89,19,38];
starAxe[83][5] = [ 0,14,43,44,23,52,49,18];
starAxe[83][6] = [ 0,85,31,81,79,21,41];

starAxe[84]    = [];                                                     
starAxe[84][0] = null;
starAxe[84][1] = [ 0,11]; 
starAxe[84][2] = [ 0,45, 3]; 
starAxe[84][3] = [ 0,25,91,89,19,38,39,20];
starAxe[84][4] = [ 0,83,17,73,74,29,71];
starAxe[84][5] = [ 0,14,33,34,15,64,66,28];
starAxe[84][6] = [ 0,86,32,80,78,21,68];

starAxe[85]    = [];                                                     
starAxe[85][0] = null;
starAxe[85][1] = [ 0,11]; 
starAxe[85][2] = [ 0,75, 9]; 
starAxe[85][3] = [ 0,31,81,79,21,41,39,18];
starAxe[85][4] = [ 0,83,14,43,44,23,52];
starAxe[85][5] = [ 0,17,37,36,15,55,57,26];
starAxe[85][6] = [ 0,87,32,90,88,19,48];

starAxe[86]    = [];                                                     
starAxe[86][0] = null;
starAxe[86][1] = [ 0,11]; 
starAxe[86][2] = [ 0,92,12]; 
starAxe[86][3] = [ 0,84,14,33,34,15,64];
starAxe[86][4] = [ 0,32,80,78,21,68,69,28];
starAxe[86][5] = [ 0,25,47,46,23,56,57,27];
starAxe[86][6] = [ 0,87,31,77,76,29,67];

starAxe[87]    = [];                                                     
starAxe[87][0] = null;
starAxe[87][1] = [ 0,11]; 
starAxe[87][2] = [ 0,82,10]; 
starAxe[87][3] = [ 0,32,90,88,19,48,49,26,];
starAxe[87][4] = [ 0,85,17,37,36,15,55];
starAxe[87][5] = [ 0,31,77,76,29,67,66,27,];
starAxe[87][6] = [ 0,86,25,47,46,23,56];
      
starAxe[88]    = [];                                                     
starAxe[88][0] = null;
starAxe[88][1] = [ 0,12]; 
starAxe[88][2] = [ 0,40, 2]; 
starAxe[88][3] = [ 0,22,78,79,30,76,74,16];
starAxe[88][4] = [ 0,89,24,46,44,13,34];
starAxe[88][5] = [ 0,19,48,49,26,57,55,15];
starAxe[88][6] = [ 0,90,32,87,85,17,37];

starAxe[89]    = [];                                                     
starAxe[89][0] = null;
starAxe[89][1] = [ 0,12]; 
starAxe[89][2] = [ 0,50, 4]; 
starAxe[89][3] = [ 0,19,38,39,20,69,71,29];
starAxe[89][4] = [ 0,91,25,84,83,17,73];
starAxe[89][5] = [ 0,24,46,44,13,34,36,16];
starAxe[89][6] = [ 0,88,22,78,79,30,76];

starAxe[90]    = [];                                                     
starAxe[90][0] = null;
starAxe[90][1] = [ 0,12]; 
starAxe[90][2] = [ 0,80,10]; 
starAxe[90][3] = [ 0,22,42,41,20,60,62,27];
starAxe[90][4] = [ 0,92,25,45,43,13,53];
starAxe[90][5] = [ 0,32,87,85,17,37,36,15];
starAxe[90][6] = [ 0,88,19,48,49,26,57];  
    
starAxe[91]    = [];                                                     
starAxe[91][0] = null;
starAxe[91][1] = [ 0,12]; 
starAxe[91][2] = [ 0,47, 3]; 
starAxe[91][3] = [ 0,92,32,82,81,30,72];
starAxe[91][4] = [ 0,24,51,52,26,61,62,28];
starAxe[91][5] = [ 0,25,84,83,17,73,74,29]
starAxe[91][6] = [ 0,89,19,38,39,20,69];    
    
starAxe[92]    = [];                                                     
starAxe[92][0] = null;
starAxe[92][1] = [ 0,12]; 
starAxe[92][2] = [ 0,86,11]; 
starAxe[92][3] = [ 0,32,82,81,30,72,71,28];
starAxe[92][4] = [ 0,91,24,51,52,26,61];
starAxe[92][5] = [ 0,25,45,43,13,53,55,27];
starAxe[92][6] = [ 0,90,22,42,41,20,60];
    
previosStarAxePoints = [];
for (v = 1; v <= 92; v++) {
    previosStarAxePoints[v] = new Set();
    for (i = 1; i<= starAxe[v].length - 1; i++) {
        for (j = 1; j <= starAxe[v][i].length - 1; j++) {
            let p = starAxe[v][i][j];
            previosStarAxePoints[v].add(p);
        }
    }
}

// Пучки для Ладей по парам (p,v)
const beamAxe = [[[[]]]];

beamAxe[0] = null;
for (p = 1; p <= 92; p++) {
    
    beamAxe[p] = [];
    
    for (v = 1; v <= 92; v++) {
        if (previosStarAxePoints[v].has(p)) {
            beamAxe[p][v] = [];
            beamAxe[p][v][0] = null;
            
            let enter = 0;
            
            for (i = 1; i<= starAxe[v].length - 1; i++) {
                beamAxe[p][v][i] = starAxe[v][i];
                
                let exclude = false;
                
                for (j = 1; j<= beamAxe[p][v][i].length - 1; j++) {
                    // подготовка исключения ЛУЧЕЙ
                    if (beamAxe[p][v][i][j] === p) {
                        exclude = true;
                        enter = beamAxe[p][v][i][1];
                    }
                }
                // исключение САМОГО ВХОДЯЩЕГО луча
                if (exclude) {
                    beamAxe[p][v][i] = null;
                }
                else {
                    beamAxe[p][v][i] = starAxe[v][i];
                }
            }
            // исключение соседних лучей
            for (i = 1; i<= starAxe[v].length - 1; i++) {
                if (enter !==0) {
                    if (next[enter].has(starAxe[v][i][1])) {
                        beamAxe[p][v][i] = null;
                    }
                }
            }
            beamAxe[p][v] = beamAxe[p][v].filter(function(element) {return element !== null});
        }
    }
}
    
///////////////////////////////  Кони (Дротики)  /////////////////////////////
const starDart = [];
starDart[ 0] = null; 

for (i =  1; i <= 32; i++) {
    starDart[i] = new Set([ ]);
}
for (i = 33; i <= 92; i++) {
    starDart[i] = new Set([ ]);
}
for (i = 33; i <= 92;  i++) {
        let xi = icoVertices[i*3 - 1 + 1];
        let yi = icoVertices[i*3 - 1 + 2];
        let zi = icoVertices[i*3 - 1 + 3];
        
        for (j = 33; j <= 92;  j++) {
            let xj = icoVertices[j*3 - 1 + 1];
            let yj = icoVertices[j*3 - 1 + 2];
            let zj = icoVertices[j*3 - 1 + 3];
            
            let d = Math.sqrt((xi-xj)*(xi-xj)+(yi-yj)*(yi-yj)+(zi-zj)*(zi-zj));
            
        if (j != i && d <= 0.8) {
            starDart[i].add(j);
        }
    }
}

// Глобально (один раз при загрузке)
const DISTANCE_MAP = new Map(); // key: `${from}-${to}`, value: distance
const IS_AXE_RAY = new Map(); // key: `${u}-${v}`, value: true/false
const IS_PIKE_RAY = new Map();
const JUMPS_MAP = new Map();
const CELLS_IN_5NET = new Set([...Array(12).keys()].map(i => i + 1).concat([...Array(60).keys()].map(i => i + 33)));
const RED_BFS_MAP = new Map(); // key: `${p}-${v}-${kingField}`, value: minMoves or Infinity
const bigRing = new Array(13); // Индексы 0..12, используем 1..12
const RING_ID_MAP = new Map(); // key: `${p}-${v}`, value: bigRingId (1..12)
const BLUE_BFS_MAP = new Array(13); // Массив из 12 карт (индексы 1..12)
const START_BFS_MAP = new Array(13); // 

//////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////// = Предрасчёты = //////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////
function precomputeAllDistances() {
    for (let from = 1; from <= 92; from++) {
        const distances = new Map();
        const openSet = new Set([from]);
        const visited = new Set();
        distances.set(from, 0);

        while (openSet.size > 0) {
            let current = null;
            let minDist = Infinity;
            for (const node of openSet) {
                const d = distances.get(node);
                if (d < minDist) {
                    minDist = d;
                    current = node;
                }
            }
            if (current === null) break;
            openSet.delete(current);
            visited.add(current);

            for (const neighbor of next[current]) {
                if (!visited.has(neighbor)) {
                    const alt = distances.get(current) + 1;
                    if (!distances.has(neighbor) || alt < distances.get(neighbor)) {
                        distances.set(neighbor, alt);
                        openSet.add(neighbor);
                    }
                }
            }
        }

        for (let to = 1; to <= 92; to++) {
            DISTANCE_MAP.set(`${from}-${to}`, distances.get(to) || Infinity);
        }
    }
}

function precomputeRayChecks() {
    for (let u = 1; u <= 92; u++) {
        const axeRays = starAxe[u];
        const pikeRays = starPike[u];

        if (Array.isArray(axeRays)) {
            for (let v = 1; v <= 92; v++) {
                const onRay = axeRays.some(ray => Array.isArray(ray) && ray.includes(v));
                IS_AXE_RAY.set(`${u}-${v}`, onRay);
            }
        }

        if (Array.isArray(pikeRays)) {
            for (let v = 1; v <= 92; v++) {
                const onRay = pikeRays.some(ray => Array.isArray(ray) && ray.includes(v));
                IS_PIKE_RAY.set(`${u}-${v}`, onRay);
            }
        }
    }
}
// для коней
function precomputeAllJumps() {
    // Для каждой возможной начальной клетки `from` (33..92)
    for (let from = 33; from <= 92; from++) {
        const jumpSet = []; 
        const visited = new Set(); 
        
        jumpSet.push([from, 0]);
        visited.add(from);
        
        while (jumpSet.length > 0) {
            const [currentCell, dist] = jumpSet.shift();
            
            // Получаем все клетки, на которые конь может прыгнуть с currentCell
            const targets = starDart[currentCell]; // Используем напрямую массив starDart
            
            if (!targets) continue;
            
            for (const nextCell of targets) {
                if (nextCell === 0 || nextCell < 33 || nextCell > 92 || visited.has(nextCell)) continue;
                
                visited.add(nextCell);
                jumpSet.push([nextCell, dist + 1]);
                
                // Сохраняем расстояние в карту
                const key = `${from}-${nextCell}`;
                JUMPS_MAP.set(key, dist + 1);
            }
        }
    }
}
// для пешек на 5-сетке
function precomputeRedBFS() {
    // Перебираем все возможные ориентации пешки в "5-сетке"
    for (const startV of CELLS_IN_5NET) {
        for (const startP of CELLS_IN_5NET) {
            // Условия для корректной пары (p, v)
            if (startP === startV) continue; // p и v не должны быть одинаковыми
            if (!next[startV].has(startP)) continue; // p должно быть соседом v

            // Для каждой возможной клетки короля
            for (let kingField = 1; kingField <= 92; kingField++) {
                // Условия для корректной клетки короля
                if (kingField === startV || kingField === startP) continue; // kingField не должен совпадать с p или v
                if (kingField >= 1 && kingField <= 12) continue; // Король не на красной клетке

                const result = redBFS(startP, startV, kingField);
                const key = `${startP}-${startV}-${kingField}`;
                RED_BFS_MAP.set(key, result);
            }
        }
    }
}
// для пешек на больших кольцах
function precomputeBigRings() {
    for (let centerCell = 1; centerCell <= 12; centerCell++) {
        const ringSet = new Set();
        
        // Перебираем все зелёные и синие клетки
        for (let v = 13; v <= 92; v++) {
            if (distance(centerCell, v) === 4) {
                ringSet.add(v);
            }
        }
        
        bigRing[centerCell] = ringSet;
    }
}
function precomputeRingIdMap() {
    // Перебираем все возможные пары (p, v)
    for (let p = 13; p <= 92; p++) { // Начинаем с 13, исключая красные
        if (p >= 13 && p <= 32 || p >= 33 && p <= 92) { // Только синие и зелёные
            for (let v = 13; v <= 92; v++) {
                if ((v >= 13 && v <= 32 || v >= 33 && v <= 92) && p !== v) { // Только синие и зелёные, не равные p
                    
                    // Проверяем все 12 bigRing
                    for (let bigRingId = 1; bigRingId <= 12; bigRingId++) {
                        if (bigRing[bigRingId].has(p) && bigRing[bigRingId].has(v)) {
                            const key = `${p}-${v}`;
                            RING_ID_MAP.set(key, bigRingId);
                            break; // Выходим, так как пара может принадлежать только одному кольцу
                        }
                    }
                }
            }
        }
    }
}
function precomputeBlueBFS() {
    for (let bigRingId = 1; bigRingId <= 12; bigRingId++) {
        const blueBigRingMap = new Map();
        const ringCells = bigRing[bigRingId];

        for (const startV of ringCells) {
            for (const startP of ringCells) {
                if (startP === startV) continue;
                if (!next[startV].has(startP)) continue;

                for (let kingField = 1; kingField <= 92; kingField++) {
                    if (ringCells.has(kingField)) continue;
                    if (kingField === startV || kingField === startP) continue;

                    const result = blueBFS(startP, startV, kingField);
                    const key = `${startP}-${startV}-${kingField}`;
                    blueBigRingMap.set(key, result);
                }
            }
        }
        BLUE_BFS_MAP[bigRingId] = blueBigRingMap;
    }
}

// расстояние в клетках
function distance(u, v) {
    return DISTANCE_MAP.get(`${u}-${v}`) || Infinity;
}
// ладейный луч
function isAxeRay(u, v) {
    return IS_AXE_RAY.get(`${u}-${v}`) || false;
}
// слоновый луч
function isPikeRay(u, v) {
    return IS_PIKE_RAY.get(`${u}-${v}`) || false;
}
// для коней
function jumps(u, v) {
    return JUMPS_MAP.get(`${u}-${v}`) || Infinity;
}
// для пешек в 5-сетке
function redBFS(p, v, k) {
    const searchQueue = [];
    const visited = new Set();
    
    // Создаём временный набор клеток "5-сетки", исключая клетку короля
    const CELLS_IN_5NET_way = new Set(CELLS_IN_5NET);
    CELLS_IN_5NET_way.delete(k);

    searchQueue.push({ p, v, moves: 0, path: [v] });
    visited.add(`${p}-${v}`);
    
    while (searchQueue.length > 0) {
        const { p: currentP, v: currentV, moves, path } = searchQueue.shift();
        
        // Проверяем, можем ли мы объявить шах с этой клетки
        if (next[k].has(currentV)) {
            const captureRays = getCaptureArrow(currentP, currentV);
            if (captureRays.includes(k)) {
                return moves;
            }
        }
        
        // Получаем следующие клетки по текущему лучу
        const moveTargets = getMoveArrow(currentP, currentV);
        for (const nextCell of moveTargets) {
            if (nextCell === 0 || !CELLS_IN_5NET_way.has(nextCell) || visited.has(`${currentV}-${nextCell}`)) {
                continue;
            }
            
            visited.add(`${currentV}-${nextCell}`);
            const newPath = [...path, nextCell];
            searchQueue.push({ 
                p: currentV, 
                v: nextCell, 
                moves: moves + 1,
                path: newPath 
            });
        }
    }
    return Infinity;
}
function getRedBFS(p, v, k) {
    const key = `${p}-${v}-${k}`;
    return RED_BFS_MAP.get(key) || Infinity;
}
// для пешек на bigRing
function getBigRingId(p, v) {
    return RING_ID_MAP.get(`${p}-${v}`) || 0;
}
function blueBFS(p, v, k) {
    const bigRingId = getBigRingId(p, v)
    
    const searchQueue = []; 
    const visited = new Set();
    
    // Создаём временный набор клеток "большого кольца", исключая клетку короля
    const RING_WAY = new Set(bigRing[bigRingId]);
    RING_WAY.delete(k);
   
        // Обычный случай: пешка уже имеет ориентацию на bigRing
    //if (!RING_WAY.has(p) || !RING_WAY.has(v)) return { moves: Infinity, path: [] };
    if (!RING_WAY.has(p) || !RING_WAY.has(v)) return Infinity;
        
    searchQueue.push({ p, v, moves: 0, path: [v] });
    visited.add(`${p}-${v}`);
    
    while (searchQueue.length > 0) {
        const { p: currentP, v: currentV, moves, path } = searchQueue.shift();
        
        // Проверяем, можем ли мы объявить шах с этой клетки
        if (next[k].has(currentV)) {
            const captureRays = getCaptureArrow(currentP, currentV);
            if (captureRays.includes(k)) {
                return moves;
            }
        }
        
        // Получаем следующие клетки по текущему лучу
        const moveTargets = getMoveArrow(currentP, currentV);
        for (const nextCell of moveTargets) {
            if (nextCell === 0 || !RING_WAY.has(nextCell) || visited.has(`${currentV}-${nextCell}`)) {
                continue;
            }
            
            visited.add(`${currentV}-${nextCell}`);
            const newPath = [...path, nextCell];
            searchQueue.push({ 
                p: currentV, 
                v: nextCell, 
                moves: moves + 1,
                path: newPath 
            });
        }
    }
    return Infinity;
}
function getBlueBFS(p, v, k) {
    const i   = getBigRingId(p, v);
    if (i > 0) {
        const key = `${p}-${v}-${k}`;
        return BLUE_BFS_MAP[i].get(key) || Infinity;
    }
    else {
        return Infinity;
    }
}
// для неходивших пешек
function startBFS(p, v, k) {
    let moves = 0;
   
    if ((p === k) || (v === k) || (p === v) || ((p !== 1 ) && (p !== 2))) {
        return Infinity;
    }
    else if (pv[1].includes(v) || pv[2].includes(v)) {
        let p1 = p0[v][1];
        let p2 = p0[v][2];
        let way1 = blueBFS(p1, v, k);
        let way2 = blueBFS(p2, v, k);
        moves = Math.min(way1, way2);
        return moves;
    }
    else {
        return Infinity;
    }
}
function getStartBFS(p, v, k) {
    if (pv[1].includes(v) || pv[2].includes(v)) {
        let p1 = p0[v][1];
        let p2 = p0[v][2];
        let way1 = getBlueBFS(p1, v, k);
        let way2 = getBlueBFS(p2, v, k);
        moves = Math.min(way1, way2);
        return moves;
    } 
    else {
        return Infinity;
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  beamAxe  //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Axe = 92;
const MAX_INDEXES_IN_BEAMS_Axe = 55595; //  если не стаить в конце 255 =>  55595 - 1 = 55594
function countOfIndexesInBeamsAxe() {
    count = 0;
    
    for (p = 1; p <= MAX_FIELD_Axe; p++) {
        for (v = 1; v <= MAX_FIELD_Axe; v++) {
            if (beamAxe[p][v]!== undefined && beamAxe[p][v]!== []) {
                for (i = 0; i <= beamAxe[p][v].length - 1; i++) {
                    for (j = 0; j <= beamAxe[p][v][i].length - 1; j++) {
                        count++;
                    }
                }
            }
        }
    }
    
    console.log(count); // = 52838
}
const beamAxeIndex = new Uint16Array((MAX_FIELD_Axe + 1) * (MAX_FIELD_Axe + 1)); // 93*93 = 8649
const beamAxeData = new Uint8Array(MAX_INDEXES_IN_BEAMS_Axe);

let beamAxeOffset = 0;

for (let p = 0; p <= MAX_FIELD_Axe; p++) {
    for (let v = 0; v <= MAX_FIELD_Axe; v++) {
        const indexPV = p * (MAX_FIELD_Axe + 1) + v;
        const beam = beamAxe[p]?.[v];

        if (!beam || beam.length === 0) {
            beamAxeIndex[indexPV] = 0xFFFF;
            continue;
        }beamAxeIndex[42 * 93 + 22]
        beamAxeIndex[indexPV] = beamAxeOffset;
        for (let i = 0; i < beam.length; i++) {
            const path = beam[i];
            if (!path || !Array.isArray(path) || path.length === 0) continue;

            for (let j = 0; j < path.length; j++) {
                const u = path[j];
                beamAxeData[beamAxeOffset++] = u;
            }
        }
        beamAxeData[beamAxeOffset++] = 0xFF;
    }
}

function getBeamAxe(p, v) {
    const indexPV = p * (MAX_FIELD_Axe + 1) + v;
    const offset = beamAxeIndex[indexPV];

    if (offset === 0xFFFF || offset >= beamAxeData.length) return [];

    const result = [];
    let i = offset;

    while (i < beamAxeData.length && beamAxeData[i] !== 0xFF) {
        result.push(beamAxeData[i]); 
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  starAxe  //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_INDEXES_IN_STAR_Axe = 3512; //  если не стаить в конце 255 =>  3512 - 1 = 3511
function countOfIndexesInStarAxe() {
count = 0;
    
    for (let v = 1; v <= MAX_FIELD_Axe; v++) {
        if (starAxe[v]!== undefined && starAxe[v]!== []) {
            for (i = 1; i <= starAxe[v].length - 1; i++) {
                for (j = 0; j <= starAxe[v][i].length - 1; j++) {
                    count++;
                }
            }
        }
    }
    
console.log(count); // = 2880
}
const starAxeIndex = new Uint16Array(MAX_FIELD_Axe + 1); // 93 
const starAxeData = new Uint8Array(MAX_INDEXES_IN_STAR_Axe);

let starAxeOffset = 0;

for (let v = 0; v <= MAX_FIELD_Axe; v++) {
    const indexV = v;
        
starAxeIndex[indexV] = 0xFF;
}

starAxeOffset = 0;
for (let v = 0; v <= MAX_FIELD_Axe; v++) {
    const indexV = v;
    const star = starAxe[v];

    if (!star || star.length === 0) {
    starAxeIndex[indexV] = 0xFFFF;
        continue;
    }
starAxeIndex[indexV] = starAxeOffset;
    for (let i = 1; i < star.length; i++) {
        const path = star[i];
        if (!path || !Array.isArray(path) || path.length === 0) continue;

        for (let j = 0; j < path.length; j++) {
            const u = path[j];
        starAxeData[starAxeOffset++] = u;
        }
    }
starAxeData[starAxeOffset++] = 0xFF;
}

function getStarAxe(v) {
    const indexV = v;
    const offset = starAxeIndex[indexV];

    if (offset === 0xFFFF || offset >= starAxeData.length) return [];

    const result = [];
    let i = offset;

    while (i < starAxeData.length && starAxeData[i] !== 0xFF) {
        result.push(starAxeData[i]); 
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  beamPike  /////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Pike = 32;
const MAX_INDEXES_IN_BEAMS_Pike = 6720; // если не стаить в конце 255 => 6720 - 1 = 6719
function countOfIndexesInBeamsPike() {
    count = 0;
    
    for (p = 1; p <= MAX_FIELD_Pike; p++) {
        for (v = 1; v <= MAX_FIELD_Pike; v++) {
            if (beamPike[p][v]!== undefined && beamPike[p][v]!== []) {
                for (i = 0; i <= beamPike[p][v].length - 1; i++) {
                    for (j = 0; j <= beamPike[p][v][i].length - 1; j++) {
                        count++;
                    }
                }
            }
        }
    }
    
    console.log(count); // = 6300
}
const beamPikeIndex = new Uint16Array((MAX_FIELD_Pike + 1) * (MAX_FIELD_Pike + 1)); // 33*33 = 1089
const beamPikeData = new Uint8Array(MAX_INDEXES_IN_BEAMS_Pike);

let beamPikeOffset = 0;

for (let p = 1; p <= MAX_FIELD_Pike; p++) {
    for (let v = 1; v <= MAX_FIELD_Pike; v++) {
        const indexPV = p * (MAX_FIELD_Pike + 1) + v;
        const beam = beamPike[p]?.[v];

        if (!beam || beam.length === 0) {
            beamPikeIndex[indexPV] = 0xFFFF;
            continue;
        }
        beamPikeIndex[indexPV] = beamPikeOffset;
        for (let i = 0; i < beam.length; i++) {
            const path = beam[i];
            if (!path || !Array.isArray(path) || path.length === 0) continue;

            for (let j = 0; j < path.length; j++) {
                const u = path[j];
                beamPikeData[beamPikeOffset++] = u;
            }
        }
        beamPikeData[beamPikeOffset++] = 0xFF;
    }
}

function getBeamPike(p, v) {
    const indexPV = p * (MAX_FIELD_Pike + 1) + v;
    const offset = beamPikeIndex[indexPV];

    if (offset === 0xFFFF || offset >= beamPikeData.length) return [];

    const result = [];
    let i = offset;

    while (i < beamPikeData.length && beamPikeData[i] !== 0xFF) {
        result.push(beamPikeData[i]);
        i++;
    }
    
    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  starPike  /////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_INDEXES_IN_STAR_Pike = 572; //  если не стаить в конце 255 =>  572 - 1 = 571
function countOfIndexesInStarPike() {
count = 0;
    
    for (let v = 1; v <= MAX_FIELD_Pike; v++) {
        if (starPike[v]!== undefined && starPike[v]!== []) {
            for (i = 1; i <= starPike[v].length - 1; i++) {
                for (j = 0; j <= starPike[v][i].length - 1; j++) {
                    count++;
                }
            }
        }
    }
    
console.log(count); // = 540
}
const starPikeIndex = new Uint16Array(MAX_FIELD_Pike + 1); // 33 
const starPikeData = new Uint8Array(MAX_INDEXES_IN_STAR_Pike);

let starPikeOffset = 0;

for (let v = 0; v <= MAX_FIELD_Pike; v++) {
    const indexV = v;
        
starPikeIndex[indexV] = 0xFF;
}

starPikeOffset = 0;
for (let v = 0; v <= MAX_FIELD_Pike; v++) {
    const indexV = v;
    const star = starPike[v];

    if (!star || star.length === 0) {
    starPikeIndex[indexV] = 0xFFFF;
        continue;
    }
starPikeIndex[indexV] = starPikeOffset;
    for (let i = 1; i < star.length; i++) {
        const path = star[i];
        if (!path || !Array.isArray(path) || path.length === 0) continue;

        for (let j = 0; j < path.length; j++) {
            const u = path[j];
        starPikeData[starPikeOffset++] = u;
        }
    }
starPikeData[starPikeOffset++] = 0xFF;
}

function getStarPike(v) {
    const indexV = v;
    const offset = starPikeIndex[indexV];

    if (offset === 0xFFFF || offset >= starPikeData.length) return [];

    const result = [];
    let i = offset;

    while (i < starPikeData.length && starPikeData[i] !== 0xFF) {
        result.push(starPikeData[i]); 
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////  Arrow  ////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Arrow = 92;
const MAX_INDEXES_IN_Arrow = 2280; //  если не стаить в конце 255 =>  2280 - 1 = 2279
function countOfIndexesInBeamsArrow() {
    count = 0;
    
    for (p = 1; p <= MAX_FIELD_Arrow; p++) {
        for (v = 1; v <= MAX_FIELD_Arrow; v++) {
            if (beamArrow[p][v]!== undefined) {
                const beam = beamArrow[p]?.[v];
                beam.forEach(function(u) {
                    count++;
                });
            }
        }
    }
    
    console.log(count); // = 1740
}
const beamArrowIndex = new Uint16Array((MAX_FIELD_Arrow + 1) * (MAX_FIELD_Arrow + 1)); // 93*93 = 8649
const beamArrowData = new Uint8Array(MAX_INDEXES_IN_Arrow);
const moveArrowIndex = new Uint16Array((MAX_FIELD_Arrow + 1) * (MAX_FIELD_Arrow + 1)); // 93*93 = 8649
const moveArrowData = new Uint8Array(MAX_INDEXES_IN_Arrow);
const captureArrowIndex = new Uint16Array((MAX_FIELD_Arrow + 1) * (MAX_FIELD_Arrow + 1)); // 93*93 = 8649
const captureArrowData = new Uint8Array(MAX_INDEXES_IN_Arrow);

let beamArrowOffset = 0;
let moveArrowOffset = 0;
let captureArrowOffset = 0;

for (let p = 0; p <= MAX_FIELD_Arrow; p++) {
    for (let v = 0; v <= MAX_FIELD_Arrow; v++) {
        const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
        
        const _beam = beamArrow[p]?.[v];
        const _move = moveArrow[p]?.[v];
        const _capture = captureArrow[p]?.[v];

        if (!_beam || _beam.size === 0) {
            beamArrowIndex[indexPV] = 0xFFFF;
            moveArrowIndex[indexPV] = 0xFFFF;
            captureArrowIndex[indexPV] = 0xFFFF;
            continue;
        }
        
        beamArrowIndex[indexPV] = beamArrowOffset;
        moveArrowIndex[indexPV] = moveArrowOffset;
        captureArrowIndex[indexPV] = captureArrowOffset;
        
        _beam.forEach(function(u) {
            beamArrowData[beamArrowOffset++] = u;
        });
        beamArrowData[beamArrowOffset++] = 0xFF;
        
        _move.forEach(function(u) {
            moveArrowData[moveArrowOffset++] = u;
        });
        moveArrowData[moveArrowOffset++] = 0xFF;
        
        _capture.forEach(function(u) {
            captureArrowData[captureArrowOffset++] = u;
        });
        captureArrowData[captureArrowOffset++] = 0xFF;
    }
}

function getBeamArrow(p, v) {
    const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
    const offset = beamArrowIndex[indexPV];

    if (offset === 0xFFFF || offset >= beamArrowData.length) return [];

    const result = [];
    let i = offset;

    while (i < beamArrowData.length && beamArrowData[i] !== 0xFF) {
        result.push(beamArrowData[i]);
        i++;
    }

    return new Uint8Array(result);
}
function getMoveArrow(p, v) {
    const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
    const offset = moveArrowIndex[indexPV];

    if (offset === 0xFFFF || offset >= moveArrowData.length) return [];

    const result = [];
    let i = offset;

    while (i < moveArrowData.length && moveArrowData[i] !== 0xFF) {
        result.push(moveArrowData[i]);
        i++;
    }

    return new Uint8Array(result);
}
function getCaptureArrow(p, v) {
    const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
    const offset = captureArrowIndex[indexPV];

    if (offset === 0xFFFF || offset >= captureArrowData.length) return [];

    const result = [];
    let i = offset;

    while (i < captureArrowData.length && captureArrowData[i] !== 0xFF) {
        result.push(captureArrowData[i]);
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////  First Arrow  //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_first = 20;
const MAX_INDEXES_IN_first_move = 20*(2 + 1) - 0; //  если не стаить в конце 255 =>  20*2 + 20(границы 255) - 1 = 59
const MAX_INDEXES_IN_first_capture = 20*(6 + 1) - 0; //  если не стаить в конце 255 =>  20*6 + 20(границы 255) - 1 = 139
const firstMoveArrowIndex = new Uint16Array((MAX_FIELD_first + 1) * (MAX_FIELD_first + 1)); // 3*21 = 61
const firstMoveArrowData = new Uint8Array(MAX_INDEXES_IN_first_move);
const firstCaptureArrowIndex = new Uint16Array((MAX_FIELD_first + 1) * (MAX_FIELD_first + 1)); // 3*21 = 61
const firstCaptureArrowData = new Uint8Array(MAX_INDEXES_IN_first_capture);

let firstMoveArrowOffset = 0;
let firstCaptureArrowOffset = 0;

for (let p = 0; p <= MAX_FIELD_Arrow; p++) {
    for (let v = 0; v <= MAX_FIELD_Arrow; v++) {   
        
        const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
            
        if ((p !== v) && ((p === 1 && pv[1].includes(v)) || (p === 2 && pv[2].includes(v)))) {
        
            const _firstMove = firstMoveArrow[p][v];
            const _firstCapture = firstCaptureArrow[p][v];
            
            firstMoveArrowIndex[indexPV] = firstMoveArrowOffset;
            firstCaptureArrowIndex[indexPV] = firstCaptureArrowOffset;
            
            _firstMove.forEach(function(u) {
                firstMoveArrowData[firstMoveArrowOffset++] = u;
            });
            firstMoveArrowData[firstMoveArrowOffset++] = 0xFF;
            
            _firstCapture.forEach(function(u) {
                firstCaptureArrowData[firstCaptureArrowOffset++] = u;
            });
            firstCaptureArrowData[firstCaptureArrowOffset++] = 0xFF;
        }
        
        else {
            firstMoveArrowIndex[indexPV] = 0xFFFF;
            firstCaptureArrowIndex[indexPV] = 0xFFFF;
        }
    }
}

function getFirstMoveArrow(p, v) {
    const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
    const offset = firstMoveArrowIndex[indexPV];

    if (offset === 0xFFFF || offset >= firstMoveArrowData.length) return [];

    const result = [];
    let i = offset;

    while (i < firstMoveArrowData.length && firstMoveArrowData[i] !== 0xFF) {
        result.push(firstMoveArrowData[i]);
        i++;
    }

    return new Uint8Array(result);
}
function getFirstCaptureArrow(p, v) {
    const indexPV = p * (MAX_FIELD_Arrow + 1) + v;
    const offset = firstCaptureArrowIndex[indexPV];

    if (offset === 0xFFFF || offset >= firstCaptureArrowData.length) return [];

    const result = [];
    let i = offset;

    while (i < firstCaptureArrowData.length && firstCaptureArrowData[i] !== 0xFF) {
        result.push(firstCaptureArrowData[i]);
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////   Helm   ////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Helm = 92;
const MAX_INDEXES_IN_Helm = 12*(5 + 1) + 80*(6 + 1); //  если не стаить в конце 255 => 631
function countOfIndexesInStarHelm() {
    count = 0;
    
    for (v = 1; v <= MAX_FIELD_Helm; v++) {
        if (starHelm[v]!== undefined) {
            const star = starArrow[v];
            star.forEach(function(u) {
                count++;
            });
        }
    }
    
    console.log(count); // = 540
}
const starHelmIndex = new Uint16Array(MAX_FIELD_Helm + 1); // 93 = 93
const starHelmData = new Uint8Array(MAX_INDEXES_IN_Helm);

let starHelmOffset = 0;
for (let v = 0; v <= MAX_FIELD_Helm; v++) {
    const indexV = v;
    starHelmIndex[indexV] = 0xFF;
}

starHelmOffset = 0;

for (let v = 0; v <= MAX_FIELD_Helm; v++) {
    const indexV = v;
    const star = starHelm[v];

    if (!star || star.size === 0) {
        starHelmIndex[indexV] = 0xFFFF;
        continue;
    }
        
    starHelmIndex[indexV] = starHelmOffset;
        
    star.forEach(function(u) {
        starHelmData[starHelmOffset++] = u;
    });
    starHelmData[starHelmOffset++] = 0xFF;
}

function getStarHelm(v) {
    const indexV = v;
    const offset = starHelmIndex[indexV];

    if (offset === 0xFFFF || offset >= starHelmData.length) return [];

    const result = [];
    let i = offset;

    while (i < starHelmData.length && starHelmData[i] !== 0xFF) {
        result.push(starHelmData[i]);
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////  Castling  //////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Castling = 12;
const MAX_INDEXES_IN_Castling = 12*(5 + 1); //  если не стаить в конце 255 => 71
function countOfIndexesInStarOfCastling() {
    count = 0;
    
    for (v = 1; v <= MAX_FIELD_Castling; v++) {
        if (starOfCastling[v]!== undefined) {
            const star = starOfCastling[v];
            star.forEach(function(u) {
                count++;
            });
        }
    }
    
    console.log(count); // = 60
}
const starOfCastlingIndex = new Uint16Array(MAX_FIELD_Castling + 1); // 13*13 = 169
const starOfCastlingData = new Uint8Array(MAX_INDEXES_IN_Castling);

let starOfCastlingOffset = 0;
for (let v = 0; v <= MAX_FIELD_Castling; v++) {
    const indexV = v;
    
    starOfCastlingIndex[indexV] = 0xFF;
}

starOfCastlingOffset = 0;

for (let v = 0; v <= MAX_FIELD_Castling; v++) {
    const indexV = v;
        
    const star = starOfCastling [v];

    if (!star || star.size === 0) {
        starOfCastling[indexV] = 0xFFFF;
        continue;
    }
        
    starOfCastlingIndex[indexV] = starOfCastlingOffset;
        
    star.forEach(function(u) {
        starOfCastlingData[starOfCastlingOffset++] = u;
    });
    starOfCastlingData[starOfCastlingOffset++] = 0xFF;
}

function getStarOfCastling(v) {
    const indexV = v;
    const offset = starOfCastlingIndex[indexV];

    if (offset === 0xFFFF || offset >= starOfCastlingData.length) return [];

    const result = [];
    let i = offset;

    while (i < starOfCastlingData.length && starOfCastlingData[i] !== 0xFF) {
        result.push(starOfCastlingData[i]);
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////   Dart   ////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const MAX_FIELD_Dart = 92;
const MAX_INDEXES_IN_Dart = 60*(11 + 1); //  если не стаить в конце 255 => 719
function countOfIndexesInStarDart() {
    count = 0;
    
    for (v = 1; v <= MAX_FIELD_Dart; v++) {
        if (starDart[v]!== undefined) {
            const star = starDart[v];
            star.forEach(function(u) {
                count++;
            });
        }
    }
    
    console.log(count); // = 660
}

const starDartIndex = new Uint16Array(MAX_FIELD_Dart + 1); // 93*93 = 8649
const starDartData = new Uint8Array(MAX_INDEXES_IN_Dart);

let starDartOffset = 0;
for (let v = 0; v <= MAX_FIELD_Dart; v++) {
    const indexV = v;
    starDartIndex[indexV] = 0xFF;
}

starDartOffset = 0;

for (let v = 0; v <= MAX_FIELD_Dart; v++) {
    const indexV = v;
    const star = starDart[v];

    if (!star || star.size === 0) {
        starDartIndex[indexV] = 0xFFFF;
        continue;
    }
        
    starDartIndex[indexV] = starDartOffset;
        
    star.forEach(function(u) {
        starDartData[starDartOffset++] = u;
    });
    starDartData[starDartOffset++] = 0xFF;
}

function getStarDart(v) {
    const indexV = v;
    const offset = starDartIndex[indexV];

    if (offset === 0xFFFF || offset >= starDartData.length) return [];

    const result = [];
    let i = offset;

    while (i < starDartData.length && starDartData[i] !== 0xFF) {
        result.push(starDartData[i]);
        i++;
    }

    return new Uint8Array(result);
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////   УГРОЗЫ КОРОЛЮ   ////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
const starDangerHelm = new Array(93); // Индексы 0..92

for (let u = 1; u <= 92; u++) {
    const set = new Set();
    const colorU = colorType(u);

    // === Радиус 1: все соседи (next[u])
    for (const cell of next[u]) {
        if (cell !== 0) set.add(cell);
    }

    // === Радиус 2: соседи соседей, с учётом цвета
    for (const cell1 of next[u]) {
        if (cell1 === 0) continue;
        for (const cell2 of next[cell1]) {
            if (cell2 === 0 || cell2 === u || set.has(cell2)) continue;

            const colorCell2 = colorType(cell2);
            let accept = false;

            if (colorU === redType || colorU === blueType) {
                // Для красных/синих клеток берём только красные и синие на радиусе 2
                accept = (colorCell2 === redType || colorCell2 === blueType);
            } else { // colorU === greenType
                // Для зелёных клеток берём только зелёные на радиусе 2
                accept = (colorCell2 === greenType);
            }

            if (accept) {
                set.add(cell2);
            }
        }
    }

    starDangerHelm[u] = set;
}

function dangerKing(kingField, currentSystem) {
    let danger = 0;
    const kingColor = colorType(kingField);
    let expectedSize;
    switch (kingColor) {
        case redType:
            expectedSize = 10;
            break;
        case blueType:
            expectedSize = 12;
            break;
        case greenType:
            expectedSize = 14;
            break;
        case noType:
            expectedSize = +Infinity;
            break;
        default:
            expectedSize = +Infinity; // значение по умолчанию, на случай ошибки
    }
    
    // Проверяем, что множество заполнено корректно
    if (starDangerHelm[kingField].size !== expectedSize) {
        console.warn(`Размер starDangerHelm[${kingField}] не соответствует ожидаемому (${expectedSize})`);
        return +Infinity; // Максимальная опасность при ошибке
    }

    for (const cell of starDangerHelm[kingField]) {
        const unitOnCell = currentSystem[FIELD_UNIT + cell];
        
        // Если клетка пуста или занята вражеской фигурой (не угрожающей напрямую)
        if (unitOnCell === 0 || currentSystem[UNIT_SIDE + unitOnCell] !== currentSystem[UNIT_SIDE + currentSystem[FIELD_UNIT + kingField]]) {
            danger++;
        }
        // Клетки с нашими фигурами или атакующими вражескими фигурами (уже проверены) не увеличивают danger.
    }

    return danger;
}

const starAfar = new Array(93); 

for (let u = 1; u <= 92; u++) {
    const set = new Set();
    
    if (Array.isArray(starAxe[u])) {
        for (const ray of starAxe[u]) {
            if (!ray || !Array.isArray(ray)) continue;
            let firstCellSkipped = false;
            for (const cell of ray) {
                if (cell === 0) continue;
                if (!firstCellSkipped) {
                    firstCellSkipped = true;
                    continue;
                }
                set.add(cell);
            }
        }
    }
   
    if (u >= 1 && u <= 32 && Array.isArray(starPike[u])) {
        for (const ray of starPike[u]) {
            if (!ray || !Array.isArray(ray)) continue;
            let firstCellSkipped = false;
            for (const cell of ray) {
                if (cell === 0) continue;
                if (!firstCellSkipped) {
                    firstCellSkipped = true;
                    continue;
                }
                set.add(cell);
            }
        }
    }
    
    starAfar[u] = set;
}

function afarDangerKing(kingField, currentSystem) {
    const mySide = currentSystem[UNIT_SIDE + currentSystem[FIELD_UNIT + kingField]];
    const enemySide = 3 - mySide;
    let count = 0;

    // Перебираем все клетки в starAfar[kingField]
    for (const cell of starAfar[kingField]) {
        const unitId = currentSystem[FIELD_UNIT + cell];
        
        // Проверяем, есть ли фигура и является ли она вражеской дальнобойной
        if (unitId === 0 || currentSystem[UNIT_SIDE + unitId] !== enemySide) {
            continue;
        }
        
        const sort = currentSystem[UNIT_SORT + unitId];
        const p = currentSystem[UNIT_PREV + unitId]; // Клетка "назад"
        const v = cell; // Клетка "вперёд" (позиция самой фигуры)
        
        // Флаг: видит ли фигура короля?
        let kingInSight = false;
        
        // Для Ладьи и Ферзя: проверяем ладейные лучи
        if (sort === C_axe || sort === C_sword) {
            const beam = getBeamAxe(p, v);
            if (beam && Array.from(beam).includes(kingField)) {
                kingInSight = true;
            }
        }
        
        // Для Слона и Ферзя: проверяем слоновые лучи
        if (!kingInSight && (sort === C_pike || sort === C_sword)) {
            const beam = getBeamPike(p, v);
            if (beam && Array.from(beam).includes(kingField)) {
                kingInSight = true;
            }
        }
        
        // Если король в секторе обстрела, увеличиваем счётчик
        if (kingInSight) {
            count++;
        }
    }

    return count;
}

function jumpDangerKing(kingField, currentSystem) {
    
    if (kingField < 33) {
        return 0;
    }
    
    const mySide = currentSystem[UNIT_SIDE + currentSystem[FIELD_UNIT + kingField]];
    const enemySide = 3 - mySide;
    let totalDanger = 0;
    const maxJumps = 5;

    // Перебираем все клетки доски
    for (let dartField = 33; dartField <= 92; dartField++) {
        const unitId = currentSystem[FIELD_UNIT + dartField];
        if (unitId === 0 || currentSystem[UNIT_SORT + unitId] !== C_dart || currentSystem[UNIT_SIDE + unitId] !== enemySide) {
            continue; // Пропускаем, если нет вражеского коня
        }

        const numJumps = jumps(dartField, kingField);
        if (numJumps < maxJumps && numJumps > 0) {
            totalDanger += (maxJumps - numJumps);
        }
    }

    return totalDanger;
}

function perigeeDangerKing(kingField, currentSystem) {
    let threat = 0;
    const k = kingField;
    const kingId    = currentSystem[FIELD_UNIT + k];
    const enemySide = 3 - currentSystem[UNIT_SIDE + kingId];
    
    for (i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_SIDE + i] === enemySide) {
            const p = currentSystem[UNIT_PREV  + i];
            const v = currentSystem[UNIT_FIELD + i];
            
            startWay = getStartBFS(p,v,k); 
             blueWay = getBlueBFS(p,v,k);  
              redWay = getRedBFS(p,v,k);   
              
            if (startWay !== Infinity) {threat += (5 - startWay)};
            if (blueWay  !== Infinity) {threat += (7 - blueWay)};
            if (redWay   !== Infinity) {threat += (8 - redWay)};
        }
    }
    
    return threat;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Создание starExchange[u]
const starExchange = new Array(93); // индексы 0–92, используем 1–92
for (let u = 1; u <= 92; u++) {
    starExchange[u] = new Set();
}

// Заполнение starExchange[u]
for (let u = 1; u <= 92; u++) {
    const set = starExchange[u];

    // Всегда: ладейные лучи
    const axeSet = getStarAxe(u);
    for (const cell of axeSet) {
        if (cell !== 0) set.add(cell);
    }

    // Если u — красная или синяя (1–32): добавляем слоновые лучи
    if (u >= 1 && u <= 32) {
        const pikeSet = getStarPike(u);
        for (const cell of pikeSet) {
            if (cell !== 0) set.add(cell);
        }
    }

    // Если u — зелёная (33–92): добавляем конские прыжки
    if (u >= 33 && u <= 92) {
        const dartSet = getStarDart(u);
        for (const cell of dartSet) {
            if (cell !== 0) set.add(cell);
        }
    }
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// --- ИНИЦИАЛИЗАЦИЯ ПРЕДВАРИТЕЛЬНЫХ ВЫЧИСЛЕНИЙ ---
precomputeAllDistances();
precomputeRayChecks();
precomputeAllJumps();
    
precomputeBigRings();
precomputeRingIdMap();
precomputeRedBFS();
precomputeBlueBFS();

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////// Обработчик входящих сообщений ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// При получении сообщения от основного потока ////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
self.onmessage = function(e) {
    const { system, maxDepth, maxTime } = e.data;
    const startTime = performance.now();
    
    initZobristKeys();
    
    let bestTree = null;
    
    for (let depth = 1; depth <= maxDepth; depth++) {
        const tree = { depth: 0, activeSide: system[QUEUE], children: [] };
        buildNode(tree, depth, system);
        
        if (tree.children.length > 0) {
            bestTree = tree;
            bestTree.finalDepth = depth;
          
            // --- ОТПРАВЛЯЕМ ПРОМЕЖУТОЧНЫЙ РЕЗУЛЬТАТ ---
            self.postMessage({
                result: bestTree,
                isFinal: false // ← это не финал, но лучшее на данный момент
            });
        }

        const elapsed = performance.now() - startTime;
        if (elapsed > maxTime) {
            console.log(`⛔ Превышен лимит времени. Глубина ${depth}, время: ${elapsed.toFixed(0)}мс`);
            break;
        }
    }
    
    // --- ФИНАЛЬНЫЙ РЕЗУЛЬТАТ ---
    console.log('📤 [Worker] Отправляю финальный результат:', {
        hasBestTree: !!bestTree,
        childCount: bestTree?.children.length,
        finalDepth: bestTree?.finalDepth,
        isFinal: true
    });
    
    self.postMessage({
        result: bestTree,
        isFinal: true,
        bestTreeΩ: bestTree.Ω  // ← добавляем оценку корня
    });
};

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////// Итеративное углубление ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function iterativeDeepening(system, maxDepth, maxTime) {
    let bestTree = null;

    for (let depth = 1; depth <= maxDepth; depth++) {
        const tree = { depth: 0, activeSide: system[QUEUE], children: [] };
        buildNode(tree, depth, system);

        if (tree.children.length > 0) {
            bestTree = tree;
            bestTree.finalDepth = depth;
        }
    }

    return bestTree;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////// ХЭШИРОВАНИЕ позиций /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function hashSystem(currentSystem) {
    let hash = 0;
    
    // Проход по всем фигурам
    for (let i = 1; i <= 52; i++) {
        const currentField = currentSystem[FIELD_UNIT + i];
        const previousField = currentSystem[UNIT_PREV + i];
        
        if (currentField !== 0) {
            hash ^= zobristCurrent[i][currentField];
        }
        
        if (previousField !== 0) {
            hash ^= zobristPrevious[i][previousField];
        }
    }
    
    // Дополнительные биты для информации о ходе
    hash ^= currentSystem[QUEUE] << 32;
    hash ^= currentSystem[MOVE] << 33;
    
    return hash;
}

/////// ВСЕ возможные ходы /////////////////////
function findAllLegalMoves(currentSystem) {
    const activeSide = currentSystem[QUEUE];
    const legalMoves = [];

    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0 || currentSystem[UNIT_SIDE + i] !== activeSide) continue;
        const v = currentSystem[UNIT_FIELD + i];
        let cluster = new Set();
        switch (currentSystem[UNIT_SORT + i]) {
            case C_helm:   cluster = typeHelmUnitCluster(v, currentSystem); break;
            case C_sword:  cluster = typeSwordUnitCluster(v, currentSystem); break;
            case C_axe:    cluster = typeAxeUnitCluster(v, currentSystem); break;
            case C_pike:   cluster = typePikeUnitCluster(v, currentSystem); break;
            case C_dart:   cluster = typeDartUnitCluster(v, currentSystem); break;
            case C_arrow:  cluster = typeArrowUnitCluster(v, currentSystem); break;
            default: continue;
        }
        for (const u of cluster) {
            const targetId = currentSystem[FIELD_UNIT + u];
            if (targetId === 0 || currentSystem[UNIT_SIDE + targetId] !== activeSide) {
                legalMoves.push({ id: i, to: u });
            }
        }
    }   
    return legalMoves.length > 0 ? legalMoves : null;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// === УЗЕЛ === //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function buildNode(node, currentDepth, currentSystem, alpha = -Infinity, beta = +Infinity, maximizing = (currentSystem[QUEUE] === 1), initialDepth = currentDepth) {
    // ---- ПРОВЕРКА: ЕСТЬ ЛИ ХОДЫ У ОЧЕРЕДИ -------------------------------------------------------- //
    if (!hasAnyLegalMoves(currentSystem)) {
        console.log("МАТ ИЛИ ПАТ НАЙДЕН", currentSystem[MOVE], currentSystem[QUEUE]);
        node.children = [];
        node.Ω = currentSystem[QUEUE] === 1 ? -Infinity : +Infinity;
        return node.Ω;
    }
    // ---------------------------------------------------------------------------------------------- //
    
    if (currentDepth <= 0) {
        node.Ω = Ωfull(currentSystem);
        return node.Ω;
    }
    
    const stateHash = hashSystem(currentSystem);
    
    const cached = transpositionTable.get(stateHash);
    if (cached && cached.depth >= currentDepth) {
        node.children = [...cached.children];
        node.Ω = cached.eval;
        return node.Ω;
    }

    const nodeQueue = currentSystem[QUEUE];
    
    // -------------- ФОРМИРУЕМ underControl ОДИН РАЗ ----------------------------------------------- //
    const underControl = underEnemyControl(currentSystem);
    // ---------------------------------------------------------------------------------------------- //

    // --- СБОР ВСЕХ ХОДОВ И присвоение Rank -------------------------------------------------------- //
    const allMoves = [];
    
    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0 || currentSystem[UNIT_SIDE + i] !== nodeQueue) continue;
        const v = currentSystem[UNIT_FIELD + i];
        let iCluster = new Set();
        
        if (currentSystem[UNIT_FIELD + i] !== 0 && currentSystem[UNIT_SIDE + i] === nodeQueue) {
            switch (currentSystem[UNIT_SORT + i]) {
                case C_helm:   iCluster = typeHelmUnitCluster(v, currentSystem); break;
                case C_sword:  iCluster = typeSwordUnitCluster(v, currentSystem); break;
                case C_axe:    iCluster = typeAxeUnitCluster(v, currentSystem); break;
                case C_pike:   iCluster = typePikeUnitCluster(v, currentSystem); break;
                case C_dart:   iCluster = typeDartUnitCluster(v, currentSystem); break;
                case C_arrow:  iCluster = typeArrowUnitCluster(v, currentSystem); break;
                default:     continue;
            }
    
            if (iCluster.size === 0) continue;
        }

        for (const u of iCluster) {
            const targetUnitId = currentSystem[FIELD_UNIT + u];
            const isCapture = targetUnitId !== 0 && currentSystem[UNIT_SIDE + targetUnitId] !== currentSystem[UNIT_SIDE + i];
            const isCastling = targetUnitId !== 0 && 
                              currentSystem[UNIT_SIDE + targetUnitId] === currentSystem[UNIT_SIDE + i] && 
                              currentSystem[UNIT_SORT + i] === C_helm;
          
            const rank = getRank(i, u, (isCastling || isCapture) ? targetUnitId : 0, currentSystem, underControl);
            
            allMoves.push({
                id: i,
                v,
                u,
                rank
            });
        }
    }
    
    // ЕСЛИ НЕТ ХОДОВ 
    if (!allMoves || allMoves.length === 0) {
        console.log("НЕТ ХОДОВ");
    }

    // --- ГЛОБАЛЬНАЯ СОРТИРОВКА ПО RANK ------------------------------------------------------------ //
    allMoves.sort((a, b) => b.rank - a.rank);
    
    // Создаем Map для групп
    const groups = new Map();
    
    // Группируем ходы, сохраняя порядок
    for (const move of allMoves) {
        if (!groups.has(move.rank)) {
            groups.set(move.rank, []);
        }
        groups.get(move.rank).push(move);
    }
    
    // Перемешиваем группы, сохраняя порядок рангов
    const ranks = groups.keys();
    for (const rank of ranks) {
        const group = groups.get(rank);
        for (let i = group.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [group[i], group[j]] = [group[j], group[i]];
        }
    }
    
    // Собираем отсортированные ходы обратно в массив
    const shuffledMoves = [];
    for (const group of groups.values()) {
        shuffledMoves.push(...group);
    }

    node.children = [];
    node.Ω = maximizing ? -Infinity : +Infinity;

    for (const { id, v, u, rank } of shuffledMoves) {
        
        const targetUnitId = currentSystem[FIELD_UNIT + u];
        const isCapture = targetUnitId !== 0 && currentSystem[UNIT_SIDE + targetUnitId] !== currentSystem[UNIT_SIDE + id];
        const isCastling = targetUnitId !== 0 && 
                      currentSystem[UNIT_SIDE + targetUnitId] === currentSystem[UNIT_SIDE + id] && 
                      currentSystem[UNIT_SORT + id] === C_helm;
        let move;
        let hypotheticalSystem;
        
        if (isCapture) {
            move = '☠️';
            hypotheticalSystem = applyTreeCapture(id, targetUnitId, u, currentSystem);
        }
        else if (isCastling) {
            move = '👑';
            hypotheticalSystem = applyTreeCastling(id, targetUnitId, currentSystem);
        }
        else {
            move = '👣';
            hypotheticalSystem = applyTreeMove(id, u, currentSystem);
        }
       
        const child = {
            id, from: v, to: u, depth: node.depth + 1, activeSide: hypotheticalSystem[QUEUE],
            move, targetId: targetUnitId || 0, children: [], system: hypotheticalSystem,
            moveRank: rank
        };
        
        const kingInCheck = isKingInCheck(hypotheticalSystem);
        const canMove = hasAnyLegalMoves(hypotheticalSystem);

        if (currentDepth - 1 > 0 && !(kingInCheck && !canMove)) {
            const eval = buildNode(child, currentDepth - 1, hypotheticalSystem, alpha, beta, !maximizing);
            
            if (child.status === 'мат') {
                child.Ω = maximizing ? -Infinity : +Infinity;
            } else {
                child.Ω = eval;
            }
            if (child.status === 'разгром') {
                child.Ω = maximizing ? -Infinity : +Infinity;
            } else {
                child.Ω = eval;
            }
            
            if (maximizing) {
                node.Ω = Math.max(node.Ω, eval);
                alpha = Math.max(alpha, node.Ω);
            } else {
                node.Ω = Math.min(node.Ω, eval);
                beta = Math.min(beta, node.Ω);
            }
            if (beta <= alpha) {
                node.children.push(child);
                break;
            }
        } else {
            
            if (isFullDraw(hypotheticalSystem)) {
                child.status = 'полная_ничья';
                child.Ω = 0;
            } else if (isRazgrom(hypotheticalSystem)) {
                child.status = 'разгром';
                child.Ω = hypotheticalSystem[QUEUE] === 1 ? -Infinity : +Infinity;
            } else if (kingInCheck && !canMove) {
                child.status = 'мат';
                child.Ω = hypotheticalSystem[QUEUE] === 1 ? -Infinity : +Infinity;
            } else if (!kingInCheck && !canMove) {
                child.status = 'пат';
                child.Ω = 0;
            } else {
                child.status = '';
                child.Ω = Ωfull(hypotheticalSystem);
            }
            
            if (maximizing) {
                node.Ω = Math.max(node.Ω, child.Ω);
                alpha = Math.max(alpha, node.Ω);
            } else {
                node.Ω = Math.min(node.Ω, child.Ω);
                beta = Math.min(beta, node.Ω);
            }
        }

        node.children.push(child);
        if (beta <= alpha) break;
    }

    transpositionTable.set(stateHash, {
        depth: currentDepth,
        eval: node.Ω,
        children: [...node.children]
    });

    return node.Ω;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////// === РАНГ === //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function getRank(currentUnit, targetField, anotherUnit, currentSystem, underControl) {
    const mySide = currentSystem[UNIT_SIDE + currentUnit]; // 1 или 2
    const enemySide = 3 - mySide;
    const unitSort = currentSystem[UNIT_SORT + currentUnit];
    const targetUnit = anotherUnit || currentSystem[FIELD_UNIT + targetField];
    const targetUnitSort = currentSystem[UNIT_SORT + targetUnit];
    const currentField = currentSystem[UNIT_FIELD + currentUnit];
    
    const isCapture  = targetUnit !== 0 && currentSystem[UNIT_SIDE + targetUnit] === enemySide;
    const isCastling = targetUnit !== 0 && 
                      currentSystem[UNIT_FIELD + targetUnit] === targetField && 
                      currentSystem[UNIT_SIDE  + targetUnit] === mySide;
    const myKingInCheck     = isKingInCheck(currentSystem); 
    const isUnderThreat     = underControl.has(currentField);
    const willBeUnderThreat = underControl.has(targetField);
    const isSave            = !myKingInCheck && isUnderThreat;
    
    const    myKing      = mySide === 1 ? 1 : 27;
    const    myKingField = currentSystem[UNIT_FIELD +    myKing];
    const enemyKing      = enemySide === 1 ? 1 : 27;
    const enemyKingField = currentSystem[UNIT_FIELD + enemyKing];
    
    const degree = 100;
    
    let moveRank     = degree;
    let castlingRank = 0;
    let captureRank  = 0;
    let saveRank     = 0;
    
    if (unitSort === C_arrow) {
        moveRank += targetField <= 12 ? C_arrow_red : C_arrow_ordinary;
    } else if (unitSort === C_pike) {
        moveRank += targetField <= 12 ? C_pike_red : (targetField <= 32 ? C_pike_blue : 0);
    } else if (unitSort === C_axe) {
        moveRank += targetField <= 12 ? C_axe_red : (targetField <= 32 ? C_axe_blue : C_axe_green);
    } else if (unitSort === C_dart) {
        moveRank += C_dart;
    } else if (unitSort === C_helm) {
        moveRank += targetField <= 12 ? C_helm_red : C_helm;
    } else if (unitSort === C_sword) {
        moveRank += C_sword;
    }
    
    ///////// Ход Пешки ///////////////////////////////////////////////////////////////////////////////////////////
    if (unitSort === C_arrow) {
        let bonusDangerKing = 0;
        
        const p = currentSystem[UNIT_PREV  + currentUnit];
        const v = currentSystem[UNIT_FIELD + currentUnit];
        const k = enemyKingField;
            
        startWay = getStartBFS(p,v,k); 
         blueWay = getBlueBFS(p,v,k);  
          redWay = getRedBFS(p,v,k);   
              
        if (startWay !== Infinity) {bonusDangerKing = (5 - startWay)};
        if (blueWay  !== Infinity) {bonusDangerKing = (7 - blueWay)};
        if (redWay   !== Infinity) {bonusDangerKing = (8 - redWay)};
        
        moveRank += bonusDangerKing;
    }
    
    ///////// Ход на пустую клетку под удар ///////////////////////////////////////////////////////////////////////
    if (!isSave && targetUnit === 0 && willBeUnderThreat) {
        moveRank = 0;
    }
    
    //////////////////// СПАСЕНИЕ /////////////////////////////////////////////////////////////////////////////////
    if (isSave) {
        //////////////////// СПАСЕНИЕ под другую угрозу ///////////////////////////////////////////////////////////
        if (willBeUnderThreat) {
            saveRank = 0;
            moveRank = 0;
        }
        //////////////////// СПАСЕНИЕ на пустую клетку ///////////////////////////////////////////////////////////
        else {
            saveRank = degree + C[currentUnit];
        }
    }
    
    //////////////////// ВЗЯТИЕ ///////////////////////////////////////////////////////////////////////////////////
    if (isCapture) {
        const currentDeltaC = targetUnitSort - unitSort;
        // Если текущее взятие выгодно для нас
        if (currentDeltaC > 0) {
            captureRank = degree + 3*currentDeltaC;
        }
        else {
            captureRank = 0;
        }
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
    const resultRank = moveRank + castlingRank + saveRank + captureRank;
   
    return resultRank;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////// === ОЦЕНКА === //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function Ωfull(currentSystem) {
    let ΩL = 0;
    let ΩD = 0;

    // --- определяем клетки под боем ---
    const underThreat = underEnemyThreat(currentSystem);

    // --- оценка каждой фигуры ---
    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0) continue;
        
        const v = currentSystem[UNIT_FIELD + i];
        const p = currentSystem[UNIT_PREV + i];
        const unitSide = currentSystem[UNIT_SIDE + i];

        let iMotionCluster = new Set();

        switch (currentSystem[UNIT_SORT + i]) {
            case C_helm:   iMotionCluster = typeHelmUnitCluster(v, currentSystem);  break;
            case C_sword:  iMotionCluster = typeSwordUnitCluster(v, currentSystem); break;
            case C_axe:    iMotionCluster = typeAxeUnitCluster(v, currentSystem);   break;
            case C_pike:   iMotionCluster = typePikeUnitCluster(v, currentSystem);  break;
            case C_dart:   iMotionCluster = typeDartUnitCluster(v, currentSystem);  break;
            case C_arrow:  iMotionCluster = typeArrowUnitCluster(v, currentSystem); break;
            default: continue;
        }

        // --- МОБИЛЬНОСТЬ ---
        let ρi = 0;
        if (iMotionCluster.size > 0) {
            iMotionCluster.forEach(b => {
                const unitTestID = currentSystem[FIELD_UNIT + b];
                if (unitTestID === 0) {
                    const sort = currentSystem[UNIT_SORT + i];
                    let bonus = 1;

                    if (colorType(b) === redType) {
                        switch (sort) {
                            case C_helm:   bonus = MOBILITY_BONUS.helm.red;   break;
                            case C_sword:  bonus = MOBILITY_BONUS.sword.red;  break;
                            case C_axe:    bonus = MOBILITY_BONUS.axe.red;    break;
                            case C_pike:   bonus = MOBILITY_BONUS.pike.red;   break;
                            case C_arrow:  bonus = MOBILITY_BONUS.arrow.red;  break;
                            case C_dart:   bonus = MOBILITY_BONUS.dart.red;   break;
                        }
                    } else if (colorType(b) === blueType) {
                        switch (sort) {
                            case C_helm:   bonus = MOBILITY_BONUS.helm.blue;   break;
                            case C_sword:  bonus = MOBILITY_BONUS.sword.blue;  break;
                            case C_axe:    bonus = MOBILITY_BONUS.axe.blue;    break;
                            case C_pike:   bonus = MOBILITY_BONUS.pike.blue;   break;
                            case C_arrow:  bonus = MOBILITY_BONUS.arrow.blue;  break;
                            case C_dart:   bonus = MOBILITY_BONUS.dart.blue;   break;
                        }
                    } else if (colorType(b) === greenType) {
                        switch (sort) {
                            case C_helm:   bonus = MOBILITY_BONUS.helm.green;   break;
                            case C_sword:  bonus = MOBILITY_BONUS.sword.green;  break;
                            case C_axe:    bonus = MOBILITY_BONUS.axe.green;    break;
                            case C_pike:   bonus = MOBILITY_BONUS.pike.green;   break;
                            case C_arrow:  bonus = MOBILITY_BONUS.arrow.green;  break;
                            case C_dart:   bonus = MOBILITY_BONUS.dart.green;   break;
                        }
                    }
                    ρi += bonus;
                }
            });
        }

        // --- Размен: оценка с точки зрения КАЖДОЙ СТОРОНЫ ---
        let δi = 0;
        if (underThreat.has(v)) {
            const deltaC = getExchange(v, currentSystem, false, 3 - unitSide);
            // Вклад в итоговую оценку:
            // - Только если размен выгоден — учитываем
            // - Отражает "агрессивный потенциал": кто может выгодно начать размен
            if (deltaC > 0) {
                δi -= deltaC;  // минус, потому что размен начинает враг, а наша фигура на v — пассивна 
                //console.log('⚔️', deltaC);
            }
        }

        // --- ИТОГОВАЯ ОЦЕНКА ФИГУРЫ ---
        const αi = C[i];
        
        let βi = 0;
        if (currentSystem[UNIT_SORT + i] === C_helm) {
            const kingField = currentSystem[UNIT_FIELD + i];
            βi =        dangerKing(kingField, currentSystem) 
               +    afarDangerKing(kingField, currentSystem)
               +    jumpDangerKing(kingField, currentSystem)
               + perigeeDangerKing(kingField, currentSystem);
        }
        const Ωi = αi + ρi + δi - βi;

        if (unitSide === 1) {
            ΩL += Ωi;
        } else {
            ΩD += Ωi;
        }
    }

    return ΩL - ΩD;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////// === РАЗМЕН === //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function getExchange(u, currentSystem, logg = false, side = null) {
    const targetUnitId = currentSystem[FIELD_UNIT + u];
    
    if (typeof u !== 'number' || u <= 0 || u > 92 || targetUnitId === 0) {
        if (logg) console.warn(`Некорректная клетка u = ${u}`);
        return 0;
    }

    const participants = new Set();
    if (targetUnitId !== 0) {
        participants.add(targetUnitId);
    }

    const pad = (num) => num.toString().padStart(2, '0');

    if (logg) {
        console.log(`\n--- Участники размена на клетке ${pad(u)} ---`);
        console.table(Array.from(participants).map(unitId => ({
            Фигура: unitId,
            Сторона: currentSystem[UNIT_SIDE + unitId],
            Сорт: currentSystem[UNIT_SORT + unitId],
            Клетка: currentSystem[UNIT_FIELD + unitId]
        })));
    }

    for (const v of starExchange[u]) {
        const unitId = currentSystem[FIELD_UNIT + v];
        if (v === 0 || v === u) continue;
        const unitSide = currentSystem[UNIT_SIDE + unitId];
        const sort = currentSystem[UNIT_SORT + unitId];
        const p = currentSystem[UNIT_PREV + unitId];

        if (currentSystem[UNIT_FIELD + unitId] === 0 || participants.has(unitId)) continue;

        let cluster = [];
        const targetExists = targetUnitId !== 0;
        const targetIsFriendly = targetExists && 
                              currentSystem[UNIT_SIDE + targetUnitId] === unitSide;

        if (targetIsFriendly) {
            switch (sort) {
                case C_helm:   cluster = typeHelmSupportCluster(v, currentSystem); break;
                case C_sword:  cluster = typeSwordSupportCluster(v, currentSystem); break;
                case C_axe:    cluster = typeAxeSupportCluster(v, currentSystem); break;
                case C_pike:   cluster = typePikeSupportCluster(v, currentSystem); break;
                case C_dart:   cluster = typeDartSupportCluster(v, currentSystem); break;
                case C_arrow:  cluster = typeArrowSupportCluster(v, currentSystem); break;
                default: continue;
            }
        } else {
            switch (sort) {
                case C_helm:   cluster = typeHelmUnitCluster(v, currentSystem); break;
                case C_sword:  cluster = typeSwordUnitCluster(v, currentSystem); break;
                case C_axe:    cluster = typeAxeUnitCluster(v, currentSystem); break;
                case C_pike:   cluster = typePikeUnitCluster(v, currentSystem); break;
                case C_dart:   cluster = typeDartUnitCluster(v, currentSystem); break;
                case C_arrow:  cluster = typeArrowCaptureCluster(v, currentSystem); break;
                default: continue;
            }
        }

        if ((Array.isArray(cluster) && !cluster.includes(u)) ||
            (cluster instanceof Set && !cluster.has(u))) {
            continue;
        }

        const uColor = colorType(u);

        if (sort === C_arrow && distance(u, v) > 1) {
            continue;
        }

        if (sort === C_dart) {
            if (uColor !== greenType) continue;
            if (jumps(u, v) > 1) continue;
        }

        if (sort === C_helm) {
            continue;
        }

        participants.add(unitId);
    }

    const candidates = new Set();

    const directionalTypes = [C_axe, C_pike, C_sword];
    for (let j = 1; j <= 52; j++) {
        const v = currentSystem[UNIT_FIELD + j];
        if (v === 0 || v === u) continue;
        const unitSide = currentSystem[UNIT_SIDE + j];
        const sort = currentSystem[UNIT_SORT + j];
        const p = currentSystem[UNIT_PREV + j];

        if (currentSystem[UNIT_FIELD + j] === 0 || participants.has(j)) continue;
        if (!directionalTypes.includes(sort)) continue;

        let beam = null;
        if (sort === C_axe) beam = getBeamAxe(p, v);
        else if (sort === C_pike) beam = getBeamPike(p, v);
        else if (sort === C_sword) {
            const starAxe = getStarAxe(v);
            const starPike = getStarPike(v);
            if ((starAxe  && Array.from(starAxe ).includes(u)) ||
                (starPike && Array.from(starPike).includes(u))) {
                candidates.add(j);
                continue;
            }
        }
        if (beam && Array.from(beam).includes(u)) {
            candidates.add(j);
        }
    }

    if (logg) {
        console.log(`\n--- Кандидаты на размен на клетке ${pad(u)} ---`);
        console.table(Array.from(candidates).map(unitId => ({
            Фигура: unitId,
            Сторона: currentSystem[UNIT_SIDE + unitId],
            Сорт: currentSystem[UNIT_SORT + unitId],
            Клетка: currentSystem[UNIT_FIELD + unitId]
        })));
    }

    if (logg) {
        console.log(`\n--- Лучи Кандидатов на клетке ${pad(u)} ---`);
    }
    
    const pathsFromCascade = [];
    
    for (const unitId of candidates) {
        const v = currentSystem[UNIT_FIELD + unitId];
        const p = currentSystem[UNIT_PREV + unitId];
        const sort = currentSystem[UNIT_SORT + unitId];

        let beam = null;
        if (sort === C_axe) beam = getBeamAxe(p, v);
        else if (sort === C_pike) beam = getBeamPike(p, v);
        else if (sort === C_sword) {
            const starAxe = getStarAxe(v);
            const starPike = getStarPike(v);
            if (starAxe && Array.from(starAxe).includes(u)) beam = starAxe;
            else if (starPike && Array.from(starPike).includes(u)) beam = starPike;
        }

        if (!beam) continue;
        const rays = [];
        let current = [];
        for (const cell of beam) {
            if (cell === 0) {
                if (current.length > 0) {
                    rays.push([...current]);
                    current = [];
                }
            } else {
                current.push(cell);
            }
        }
        if (current.length > 0) rays.push(current);

        const targetRay = rays.find(ray => ray.includes(u));
        if (!targetRay) continue;

        const path = [u];
        const indexU = targetRay.indexOf(u);
        if (indexU !== -1) {
            for (let i = indexU - 1; i >= 0; i--) {
                path.push(targetRay[i]);
            }
        }
        path.push(v);
        pathsFromCascade.push(path);

        if (logg) {
            console.log(' → '.repeat(1), path.map(pad).join(' → '));
        }
    }

    if (logg) {
        console.log(`\n--- Анализ всех лучей от клетки ${pad(u)} ---`);
    }
    
    for (const path of pathsFromCascade) {
        let states = path.map(cell => {
            const unitOnCell = currentSystem[FIELD_UNIT + cell];
            if (cell === u) return `У${pad(cell)}`;
            else if (unitOnCell === 0) return `О${pad(cell)}`;
            else if (participants.has(unitOnCell)) return `У${pad(cell)}`;
            else if (candidates.has(unitOnCell)) return `К${pad(cell)}`;
            else return `П${pad(cell)}`;
        });

        if (logg) {
            console.log(`\n--- Каскадное превращение на пути: ${path.map(pad).join(' → ')} ---`);
        }
        
        if (logg) {
            console.log(' → '.repeat(1), states.join(' → '));
        }
        
        states = path.map(cell => {
            const unitOnCell = currentSystem[FIELD_UNIT + cell];
            if (cell === u) return { cell, state: 'У', unitId: targetUnitId };
            else if (unitOnCell === 0) return { cell, state: 'О', unitId: 0 };
            else if (participants.has(unitOnCell)) return { cell, state: 'У', unitId: unitOnCell };
            else if (candidates.has(unitOnCell)) return { cell, state: 'К', unitId: unitOnCell };
            else return { cell, state: 'П', unitId: unitOnCell };
        });

        let blockActive = false;
        const finalStates = [];
        for (const item of states) {
            if (item.state === 'П') blockActive = true;
            if (item.state === 'К') {
                if (blockActive) finalStates.push({ ...item, state: 'П' });
                else {
                    finalStates.push({ ...item, state: 'У' });
                    participants.add(item.unitId);
                }
            } else finalStates.push(item);
        }

        const output = finalStates.map(item => `${item.state}${pad(item.cell)}`).join(' → ');
        if (logg) {
            console.log(' → '.repeat(1), output);
        }
    }

    // --- ОСНОВНАЯ ЛОГИКА КАСКАДА ВНЕ logg ---
    for (const path of pathsFromCascade) {
        const states = path.map(cell => {
            const unitOnCell = currentSystem[FIELD_UNIT + cell];
            if (cell === u) return { cell, state: 'У', unitId: targetUnitId };
            else if (unitOnCell === 0) return { cell, state: 'О', unitId: 0 };
            else if (participants.has(unitOnCell)) return { cell, state: 'У', unitId: unitOnCell };
            else if (candidates.has(unitOnCell)) return { cell, state: 'К', unitId: unitOnCell };
            else return { cell, state: 'П', unitId: unitOnCell };
        });

        let blockActive = false;
        for (const item of states) {
            if (item.state === 'П') blockActive = true;
            if (item.state === 'К') {
                if (!blockActive) {
                    participants.add(item.unitId);
                }
            }
        }
    }

    if (logg) {
        console.log(`\n--- Объединённые лучи после каскада ---`);
        const tableData = [];
        for (const path of pathsFromCascade) {
            let states = path.map(cell => {
                const unitOnCell = currentSystem[FIELD_UNIT + cell];
                if (cell === u) return `У${pad(cell)}`;
                else if (unitOnCell === 0) return `О${pad(cell)}`;
                else if (participants.has(unitOnCell)) return `У${pad(cell)}`;
                else if (candidates.has(unitOnCell)) return `К${pad(cell)}`;
                else return `П${pad(cell)}`;
            });

            states = path.map(cell => {
                const unitOnCell = currentSystem[FIELD_UNIT + cell];
                if (cell === u) return { cell, state: 'У', unitId: targetUnitId };
                else if (unitOnCell === 0) return { cell, state: 'О', unitId: 0 };
                else if (participants.has(unitOnCell)) return { cell, state: 'У', unitId: unitOnCell };
                else if (candidates.has(unitOnCell)) return { cell, state: 'К', unitId: unitOnCell };
                else return { cell, state: 'П', unitId: unitOnCell };
            });

            let blockActive = false;
            const finalStates = [];
            for (const item of states) {
                if (item.state === 'П') blockActive = true;
                if (item.state === 'К') {
                    if (blockActive) finalStates.push({ ...item, state: 'П' });
                    else {
                        finalStates.push({ ...item, state: 'У' });
                    }
                } else finalStates.push(item);
            }

            const output = finalStates.map(item => `${item.state}${pad(item.cell)}`).join(' → ');
            tableData.push({ Путь: output });
        }
        console.table(tableData);
    }

    if (side === null) side = currentSystem[QUEUE];
    const targetSide = currentSystem[UNIT_SIDE + targetUnitId];
    if (targetSide === side) {
        if (logg) console.log("    Целевая фигура — своя. Размен неактуален.");
        return 0;
    }

    participants.delete(targetUnitId);

    const myParticipants = new Set();
    const enemyParticipants = new Set();
    for (const unitId of participants) {
        const unitSide = currentSystem[UNIT_SIDE + unitId];
        if (unitSide === side) myParticipants.add(unitId);
        else if (unitSide !== side) enemyParticipants.add(unitId);
    }

    if (myParticipants.size === 0) {
        if (logg) console.log("    Нет своих фигур для взятия.");
        return 0;
    }

    const getSortedUnits = (unitSet) => {
        return Array.from(unitSet).sort((a, b) => currentSystem[UNIT_SORT + a] - currentSystem[UNIT_SORT + b]);
    };

    let ourLoss = 0;
    let enemyLoss = 0;
    let lastSide = null;

    enemyLoss += currentSystem[UNIT_SORT + targetUnitId];
    lastSide = targetSide;

    // --- СИМУЛЯЦИЯ размена ---
    const myUnitsSim = getSortedUnits(myParticipants);
    const enemyUnitsSim = getSortedUnits(enemyParticipants);
    let myIndex = 0;
    let enemyIndex = 0;

    while (true) {
        if (lastSide !== side && myIndex < myUnitsSim.length) {
            const next = myUnitsSim[myIndex++];
            const cost = currentSystem[UNIT_SORT + next];
            if (enemyIndex < enemyUnitsSim.length) ourLoss += cost;
            lastSide = side;
        }
        else if (lastSide === side && enemyIndex < enemyUnitsSim.length) {
            const next = enemyUnitsSim[enemyIndex++];
            const cost = currentSystem[UNIT_SORT + next];
            if (myIndex < myUnitsSim.length) enemyLoss += cost;
            lastSide = targetSide;
        } else break;
    }

    // --- ТОЛЬКО ВЫВОД ДЛЯ logg ---
    if (logg) {
        console.log(`\n--- Симуляция размена на клетке ${pad(u)} ---`);
        const moves = [];
        moves.push({
            '№': 0,
            Ход: 'враг',
            Фигура: targetUnitId,
            Сорт: currentSystem[UNIT_SORT + targetUnitId],
            Действие: 'снята'
        });
        let moveNumber = 1;
        let simLastSide = targetSide;
        let simMyIndex = 0;
        let simEnemyIndex = 0;
        while (true) {
            if (simLastSide !== side && simMyIndex < myUnitsSim.length) {
                const next = myUnitsSim[simMyIndex++];
                moves.push({
                    '№': moveNumber++,
                    Ход: 'свои',
                    Фигура: next,
                    Сорт: currentSystem[UNIT_SORT + next],
                    Действие: 'берёт'
                });
                simLastSide = side;
            }
            else if (simLastSide === side && simEnemyIndex < enemyUnitsSim.length) {
                const next = enemyUnitsSim[simEnemyIndex++];
                moves.push({
                    '№': moveNumber++,
                    Ход: 'враг',
                    Фигура: next,
                    Сорт: currentSystem[UNIT_SORT + next],
                    Действие: 'берёт'
                });
                simLastSide = targetSide;
            } else break;
        }
        console.table(moves);
    }

    const deltaC = enemyLoss - ourLoss;

    if (logg) {
        console.log(`\n---⚖️ Баланс размена ⚖️️---`);
        console.table({
            Баланс: { 'ΔС': deltaC },
            Потери: { Враг: enemyLoss, Свои: ourLoss }
        });
    }
    
    //////////////////////////////////////
    // Создаём упорядоченный массив участников размена: [цель, фигура1, фигура2, ...]
    const sortedParticipants = [targetUnitId];
    let remainingParticipants = new Set(participants);
    remainingParticipants.delete(targetUnitId);
    
    let nextSidePartial = 3 - currentSystem[UNIT_SIDE + targetUnitId]; // Сторона, ходящая первой после цели
    
    while (remainingParticipants.size > 0) {
        const candidates = Array.from(remainingParticipants).filter(id => currentSystem[UNIT_SIDE + id] === nextSidePartial);
        if (candidates.length === 0) break;
    
        const chosenId = candidates.reduce((minId, id) => C[id] < C[minId] ? id : minId);
        sortedParticipants.push(chosenId);
        remainingParticipants.delete(chosenId);
        nextSidePartial = 3 - nextSidePartial;
    }
    
    // Рассчитываем частичные суммы delta для каждой "точки выхода"
    let totalDelta = C[targetUnitId]; // Начинаем с плюса за цель
    let partialSums = [];
    
    for (let i = 1; i < sortedParticipants.length - 1; i++) { // Исключаем последнюю фигуру
        const unitId = sortedParticipants[i];
        // Если сторона совпадает с инициатором (side), то это наша фигура — минус
        // Если не совпадает, то вражеская — плюс
        totalDelta += (currentSystem[UNIT_SIDE + unitId] === side ? -C[unitId] : +C[unitId]);
        partialSums.push(totalDelta);
    }
    
    // Возвращаем среднее арифметическое всех "частичных сумм"
    const averageDelta = partialSums.length > 0 
        ? Math.round(partialSums.reduce((a, b) => a + b, 0) / partialSums.length) 
        : 0;
    
    return averageDelta;
    //return partialSums;
    //return deltaC;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///// функции специальных состояний //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function isKingInCheck(currentSystem) {
    const activeSide = currentSystem[QUEUE];
    const kingId = activeSide === 1 ? 1 : 27;

    const vKing = currentSystem[UNIT_FIELD + kingId];
    if (!vKing || currentSystem[UNIT_SORT + kingId] !== C_helm) return false;

    for (let enemyId = 1; enemyId <= 52; enemyId++) {
        if (currentSystem[UNIT_SIDE + enemyId] === activeSide || currentSystem[UNIT_FIELD + enemyId] === 0) continue;

        const vEnemy = currentSystem[UNIT_FIELD + enemyId];
        const cluster = (() => {
            switch (currentSystem[UNIT_SORT + enemyId]) {
                case C_helm:  return typeHelmAutoCheckCluster(vEnemy, currentSystem);
                case C_axe:   return typeAxeAutoCheckCluster(vEnemy, currentSystem);
                case C_pike:  return typePikeAutoCheckCluster(vEnemy, currentSystem);
                case C_dart:  return typeDartAutoCheckCluster(vEnemy, currentSystem);
                case C_sword: return typeSwordAutoCheckCluster(vEnemy, currentSystem);
                case C_arrow: return typeArrowAutoCheckCluster(vEnemy, currentSystem);
                default:      return new Set();
            }
        })();

        if (cluster.has(vKing)) {
            return true; // король под шахом
        }
    }

    return false;
}

function hasAnyLegalMoves(currentSystem) {
    const activeSide = currentSystem[QUEUE];
    const unitIds = [];

    // Сбор юнитов текущей очереди
    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] !== 0 && currentSystem[UNIT_SIDE + i] === activeSide) {
            const v = currentSystem[UNIT_FIELD + i];

            const cluster = (() => {
                switch (currentSystem[UNIT_SORT + i]) {
                    case C_helm:   return typeHelmUnitCluster(v, currentSystem);
                    case C_sword:  return typeSwordUnitCluster(v, currentSystem);
                    case C_axe:    return typeAxeUnitCluster(v, currentSystem);
                    case C_pike:   return typePikeUnitCluster(v, currentSystem);
                    case C_dart:   return typeDartUnitCluster(v, currentSystem);
                    case C_arrow:  return typeArrowUnitCluster(v, currentSystem);
                    default:       return new Set();
                }
            })();

            if (cluster.size > 0) {
                return true; // нашёлся хотя бы один ход
            }
        }
    }

    return false;
}

function isFullDraw(currentSystem) {
    let lightCount = 0;
    let darkCount = 0;

    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0) continue;

        const side = currentSystem[UNIT_SIDE + i];
        if (currentSystem[UNIT_SORT + i] === C_helm) continue;

        if (side === 1) lightCount++;
        else if (side === 2) darkCount++;
    }

    return lightCount === 0 && darkCount === 0;
}

function isRazgrom(currentSystem) {
    const activeSide = currentSystem[QUEUE];
    let count = 0;

    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0) continue;
        if (currentSystem[UNIT_SIDE + i] === activeSide && currentSystem[UNIT_SORT + i] !== C_helm) {
            count++;
        }
    }

    return count === 0;
}

function underEnemyThreat(currentSystem) {
    const underThreat = new Set();

    for (let i = 1; i <= 52; i++) {
        if (currentSystem[UNIT_FIELD + i] === 0) continue;

        const v = currentSystem[UNIT_FIELD + i];
        const side = currentSystem[UNIT_SIDE + i];
        const sort = currentSystem[UNIT_SORT + i];

        let attackCluster = new Set();

        switch (sort) {
            case C_helm:   attackCluster = typeHelmUnitCluster(v, currentSystem); break;
            case C_sword:  attackCluster = typeSwordUnitCluster(v, currentSystem); break;
            case C_axe:    attackCluster = typeAxeUnitCluster(v, currentSystem); break;
            case C_pike:   attackCluster = typePikeUnitCluster(v, currentSystem); break;
            case C_dart:   attackCluster = typeDartUnitCluster(v, currentSystem); break;
            case C_arrow:  attackCluster = typeArrowUnitCluster(v, currentSystem); break;
            default: continue;
        }

        for (const u of attackCluster) {
            const targetId = currentSystem[FIELD_UNIT + u];
            if (targetId !== 0 && currentSystem[UNIT_SIDE + targetId] !== side) {
                underThreat.add(u);
            }
        }
    }
    
    return underThreat;
}

function underEnemyControl(currentSystem) {
    const underControl = new Set();
    
    for (let enemy = 1; enemy <= 52; enemy++) {
        if (currentSystem[UNIT_FIELD + enemy] === 0) continue;
        const side = currentSystem[UNIT_SIDE + enemy];
        if (side === currentSystem[QUEUE]) continue; // не противник
        const v = currentSystem[UNIT_FIELD + enemy];
        let attackCluster = new Set();
    
        switch (currentSystem[UNIT_SORT + enemy]) {
            case C_helm:   attackCluster = typeHelmUnitCluster(v, currentSystem); break;
            case C_sword:  attackCluster = typeSwordUnitCluster(v, currentSystem); break;
            case C_axe:    attackCluster = typeAxeUnitCluster(v, currentSystem); break;
            case C_pike:   attackCluster = typePikeUnitCluster(v, currentSystem); break;
            case C_dart:   attackCluster = typeDartUnitCluster(v, currentSystem); break;
            case C_arrow:  attackCluster = typeArrowControlCluster(v, currentSystem); break;
            default: continue;
        }
        
        switch (currentSystem[UNIT_SORT + enemy]) {
            case C_helm:   supportCluster = typeHelmSupportCluster(v, currentSystem); break;
            case C_sword:  supportCluster = typeSwordSupportCluster(v, currentSystem); break;
            case C_axe:    supportCluster = typeAxeSupportCluster(v, currentSystem); break;
            case C_pike:   supportCluster = typePikeSupportCluster(v, currentSystem); break;
            case C_dart:   supportCluster = typeDartSupportCluster(v, currentSystem); break;
            case C_arrow:  supportCluster = typeArrowSupportCluster(v, currentSystem); break;
            default: continue;
        }
    
        for (const u of attackCluster) {
            const targetId = currentSystem[FIELD_UNIT + u];
            underControl.add(u);
        }
        
        for (const u of supportCluster) {
            const targetId = currentSystem[FIELD_UNIT + u];
            underControl.add(u);
        }
    }
    
    return underControl;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// === ТИПЫ ХОДОВ === ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function applyTreeMove(unitId, targetField, currentSystem) {
    const oldField = currentSystem[UNIT_FIELD + unitId];

    // Создаём копию типизированного массива
    const newSystem = new Uint8Array(currentSystem);

    // Освобождаем старое поле
    newSystem[FIELD_UNIT + oldField] = 0;
    // Занимаем новое поле
    newSystem[FIELD_UNIT + targetField] = unitId;
    // Обновляем позицию фигуры
    newSystem[UNIT_FIELD + unitId] = targetField;
    // Обновляем предыдущее поле
    newSystem[UNIT_PREV + unitId] = oldField;
    
    // === ФУНДАМЕНТАЛЬНОЕ: СМЕНА ОЧЕРЕДИ ===
    newSystem[QUEUE] = 3 - currentSystem[QUEUE];
    // =============================================

    return newSystem;
}

function applyTreeCapture(unitId, targetUnitId, targetField, currentSystem) {
    const oldField = currentSystem[UNIT_FIELD + unitId];

    // Создаём копию типизированного массива
    const newSystem = new Uint8Array(currentSystem);
    const enemyOldField = newSystem[UNIT_FIELD + targetUnitId];

    // Освобождаем старое поле атакующего
    newSystem[FIELD_UNIT + oldField] = 0;

    // Убираем фигуру противника с доски
    newSystem[FIELD_UNIT + enemyOldField] = 0;
    newSystem[UNIT_FIELD + targetUnitId] = 0; // делаем фигуру "мертвой"

    // Размещаем атакующего на новом поле
    newSystem[FIELD_UNIT + targetField] = unitId;
    newSystem[UNIT_FIELD + unitId] = targetField;
    newSystem[UNIT_PREV + unitId] = oldField;
    
    // === ФУНДАМЕНТАЛЬНОЕ: СМЕНА ОЧЕРЕДИ ===
    newSystem[QUEUE] = 3 - currentSystem[QUEUE];
    // =============================================

    return newSystem;
}

function applyTreeCastling(kingId, viceId, currentSystem) {
    const kingOldField = currentSystem[UNIT_FIELD + kingId];
    const viceOldField = currentSystem[UNIT_FIELD + viceId];

    const newSystem = new Uint8Array(currentSystem);

    // Освобождаем старые поля
    newSystem[FIELD_UNIT + kingOldField] = 0;
    newSystem[FIELD_UNIT + viceOldField] = 0;

    // Обмениваемся позициями
    newSystem[UNIT_FIELD + kingId] = viceOldField;
    newSystem[UNIT_FIELD + viceId] = kingOldField;

    // Занимаем новые поля
    newSystem[FIELD_UNIT + viceOldField] = kingId;
    newSystem[FIELD_UNIT + kingOldField] = viceId;

    // Обновляем previos для короля
    newSystem[UNIT_PREV + kingId] = kingOldField;
    // Обновляем previos для партнёра
    newSystem[UNIT_PREV + viceId] = viceOldField;

    // После рокировки партнер уже не может рокироваться снова
    newSystem[UNIT_CASTLING + viceId] = 0;
    
    // === ФУНДАМЕНТАЛЬНОЕ: СМЕНА ОЧЕРЕДИ ===
    newSystem[QUEUE] = 3 - currentSystem[QUEUE];
    // =============================================

    return newSystem;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// === typeXXXUnitCluster === ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeHelmUnitCluster(v, currentSystem) {
    let result  = new Set();
    let usual   = new Set();
    let special = new Set();
    
    // Чтение из currentSystem
    const vUnitId = currentSystem[FIELD_UNIT + v];
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    
    let starUsual = getStarHelm(v);
    usual = processList(vUnitId, starUsual, currentSystem, ownSide, true);
    let starSpecial = getStarOfCastling (v);
    special = processCastlingList(vUnitId, starSpecial, currentSystem, ownSide, true);
    
    // Объединяем кластеры
    result = new Set([...usual, ...special]);

    return result;
}

function typeDartUnitCluster(v, currentSystem) {
    let result = new Set();

    // Чтение из currentSystem
    const vUnitId = currentSystem[FIELD_UNIT + v];
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2

    // Использование старой логики для star и processList
    const star = getStarDart(v);
    
    result = processList(vUnitId, star, currentSystem, ownSide, true);
    
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeSwordUnitCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;

    const pikeSet = typeSectionCluster(v, C_pike, currentSystem);
    const axeSet  = typeSectionCluster(v, C_axe,  currentSystem);

    // Объединяем кластеры
    result = new Set([...pikeSet, ...axeSet]);

    return result;
}

function typeSectionCluster(v, sort, currentSystem) {
    let result = new Set();
    let section;

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;

    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2

    if (sort === C_axe) {
        section = getStarAxe(v);
    }
    if (sort === C_pike) {
        section = getStarPike(v);
    }

    result = processRay(vUnitId, section, currentSystem, ownSide, true);

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeAxeUnitCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    let beam = getBeamAxe(p, v);
    if (!p || !beam) return result;
    result = processRay(vUnitId, beam, currentSystem, ownSide, true);

    return result;
}

function typePikeUnitCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    let beam = getBeamPike(p, v);
    if (!p || !beam) return result;
    result = processRay(vUnitId, beam, currentSystem, ownSide, true);

    return result;
}

function typeArrowUnitCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    const stepZero = (
        (ownSide === 1 && p === 1 && !lSet.has(v)) ||
        (ownSide === 2 && p === 2 && !dSet.has(v))
    );

    if (stepZero) {
        let firstMove = processMoveList(vUnitId, getFirstMoveArrow(p, v), currentSystem, ownSide, true);
        let firstCapture = processCaptureList(vUnitId, getFirstCaptureArrow(p, v), currentSystem, ownSide, true);

        result = new Set([...firstMove, ...firstCapture]);
    } else {
        let usualMove = processMoveList(vUnitId, getMoveArrow(p, v), currentSystem, ownSide, true);
        let usualCapture = processCaptureList(vUnitId, getCaptureArrow(p, v), currentSystem, ownSide, true);

        result = new Set([...usualMove, ...usualCapture]);
    }

    return result;
}

function typeArrowCaptureCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    const stepZero = (
        (ownSide === 1 && p === 1 && !lSet.has(v)) ||
        (ownSide === 2 && p === 2 && !dSet.has(v))
    );

    if (stepZero) {
        let firstCapture = processCaptureList(vUnitId, getFirstCaptureArrow(p, v), currentSystem, ownSide, true);

        result = firstCapture;
    } else {
        let usualCapture = processCaptureList(vUnitId, getCaptureArrow(p, v), currentSystem, ownSide, true);

        result = usualCapture;
    }

    return result;
}

function typeArrowSupportCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    const stepZero = (
        (ownSide === 1 && p === 1 && !lSet.has(v)) ||
        (ownSide === 2 && p === 2 && !dSet.has(v))
    );

    if (stepZero) {
        let firstCapture = processSupportList(vUnitId, getFirstCaptureArrow(p, v), currentSystem, ownSide, true);

        result = firstCapture;
    } else {
        let usualCapture = processSupportList(vUnitId, getCaptureArrow(p, v), currentSystem, ownSide, true);

        result = usualCapture;
    }

    return result;
}

function typeArrowControlCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    const stepZero = (
        (ownSide === 1 && p === 1 && !lSet.has(v)) ||
        (ownSide === 2 && p === 2 && !dSet.has(v))
    );

    if (stepZero) {
        let firstMove = processMoveList(vUnitId, getFirstMoveArrow(p, v), currentSystem, ownSide, true);
        let firstCapture = processControlList(vUnitId, getFirstCaptureArrow(p, v), currentSystem, ownSide, true);

        result = new Set([...firstMove, ...firstCapture]);
    } else {
        let usualMove = processMoveList(vUnitId, getMoveArrow(p, v), currentSystem, ownSide, true);
        let usualCapture = processControlList(vUnitId, getCaptureArrow(p, v), currentSystem, ownSide, true);

        result = new Set([...usualMove, ...usualCapture]);
    }

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////// === typeXXXSupportCluster === /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeHelmSupportCluster(v, currentSystem) {
    let result  = new Set();
    let usual   = new Set();
    
    // Чтение из currentSystem
    const vUnitId = currentSystem[FIELD_UNIT + v];
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    
    let starUsual = getStarHelm(v);
    usual = supportList(vUnitId, starUsual, currentSystem, ownSide);
    
    // Объединяем кластеры
    result = usual;

    return result;
}

function typeDartSupportCluster(v, currentSystem) {
    let result = new Set();

    // Чтение из currentSystem
    const vUnitId = currentSystem[FIELD_UNIT + v];
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2

    // Использование старой логики для star и processList
    const star = getStarDart(v);
    
    result = supportList(vUnitId, star, currentSystem, ownSide);
    
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeSwordSupportCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;

    const pikeSet = typeSectionSupportCluster(v, C_pike, currentSystem);
    const axeSet  = typeSectionSupportCluster(v, C_axe,  currentSystem);

    // Объединяем кластеры
    // SUPPORT учитывает только гипотетические взятия на клетки, где убьют нашего
    result = new Set([...pikeSet, ...axeSet]);

    return result;
}

function typeSectionSupportCluster(v, sort, currentSystem) {
    let result = new Set();
    let section;

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;

    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2

    if (sort === C_axe) {
        section = getStarAxe(v);
    }
    if (sort === C_pike) {
        section = getStarPike(v);
    }
    // SUPPORT учитывает только гипотетические взятия на клетки, где убьют нашего
    result = supportRay(vUnitId, section, currentSystem, ownSide, true);

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeAxeSupportCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];

    let beam = getBeamAxe(p, v);
    if (!p || !beam) return result;
    // SUPPORT учитывает только гипотетические взятия на клетки, где убьют нашего
    result = supportRay(vUnitId, beam, currentSystem, ownSide);

    return result;
}

function typePikeSupportCluster(v, currentSystem) {
    let result = new Set();

    const vUnitId = currentSystem[FIELD_UNIT + v];
    if (!vUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + vUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + vUnitId];
     
    let beam = getBeamPike(p, v);
    if (!p || !beam) return result;
    // SUPPORT учитывает только гипотетические взятия на клетки, где убьют нашего
    result = supportRay(vUnitId, beam, currentSystem, ownSide);

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////// typeTestAutoCheck  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeTestAutoCheck(unitId, targetField, currentSystem) {
    const hypotheticalSystem = applyTestMove(unitId, targetField, currentSystem);
    const mySide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2
    const kingId = mySide === 1 ? 1 : 27;
    const kingField = hypotheticalSystem[UNIT_FIELD + kingId];
    let nextField, star, star1, star2;

    for (let enemyUnitId = 1; enemyUnitId <= 52; enemyUnitId++) {
        if (hypotheticalSystem[UNIT_SIDE + enemyUnitId] === mySide) continue;
        if (hypotheticalSystem[UNIT_FIELD + enemyUnitId] === 0) continue;

        const enemySort = hypotheticalSystem[UNIT_SORT + enemyUnitId];
        const enemyField = hypotheticalSystem[UNIT_FIELD + enemyUnitId];

        let autoCheckCluster = new Set();

        if (enemySort === C_helm) {
            nextField = getStarHelm(kingField);
            if (nextField.includes(enemyField)) {
                return true;
            }
        }
        if (enemySort === C_axe) {
            star = getStarAxe(kingField);
            if (star.includes(enemyField)) {
                autoCheckCluster = typeAxeAutoCheckCluster(enemyField, hypotheticalSystem);
            }
        }
        if (enemySort === C_pike && kingField <= 32) {
            star = getStarPike(kingField);
            if (star.includes(enemyField)) {
                autoCheckCluster = typePikeAutoCheckCluster(enemyField, hypotheticalSystem);
            }
        }
        if (enemySort === C_sword) {
            star1 = getStarAxe(kingField);
            star2 = getStarPike(kingField);
            if (star1.includes(enemyField) || star2.includes(enemyField)) {
                autoCheckCluster = typeSwordAutoCheckCluster(enemyField, hypotheticalSystem);
            }
        }
        if (enemySort === C_dart && kingField > 32) {
            star = getStarDart(kingField);
            if (star.includes(enemyField)) {
                return true;
            }
        }
        if (enemySort === C_arrow) {
            nextField = getStarHelm(kingField);
            if (nextField.includes(enemyField)) {
                autoCheckCluster = typeArrowAutoCheckCluster(enemyField, hypotheticalSystem);
            }
        }
        if (autoCheckCluster.has(kingField)) {
            return true;
        }
    }

    return false;
}

function applyTestMove(unitId, targetField, currentSystem) {
    const newSystem = new Uint8Array(currentSystem);

    const oldField = newSystem[UNIT_FIELD + unitId];
    const targetUnitId = newSystem[FIELD_UNIT + targetField]; // фигура на целевом поле

    // +++ УДАЛЕНИЕ ВРАЖЕСКОЙ ФИГУРЫ (ЕСЛИ ЕСТЬ)
    if (targetUnitId !== 0) {
        newSystem[UNIT_FIELD + targetUnitId] = 0; // делаем фигуру "мёртвой"
    }

    // Освобождаем старое поле
    newSystem[FIELD_UNIT + oldField] = 0;
    // Занимаем новое поле
    newSystem[FIELD_UNIT + targetField] = unitId;
    // Обновляем позицию фигуры
    newSystem[UNIT_FIELD + unitId] = targetField;
    // Обновляем предыдущее поле
    newSystem[UNIT_PREV + unitId] = oldField;
    
    //
    newSystem[QUEUE] = 3 - currentSystem[QUEUE];

    return newSystem;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////// === typeXXXAutoCheckCluster === /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeHelmAutoCheckCluster(w, currentSystem) {
    let result  = new Set();
    let usual   = new Set();
    
    // Чтение из currentSystem
    const wUnitId = currentSystem[FIELD_UNIT + w];
    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2
    
    let starUsual = getStarHelm(w);
    usual = processList(wUnitId, starUsual, currentSystem, ownSide, false);
    
    result = usual;
    
    return result;
}

function typeDartAutoCheckCluster(w, currentSystem) {
    let result = new Set();
    
    const wUnitId = currentSystem[FIELD_UNIT + w];
    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2
    
    let star = getStarDart(w);
    result = processList(wUnitId, star, currentSystem, ownSide, false);
     
    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeSwordAutoCheckCluster(w, currentSystem) {
    let result = new Set();

    const wUnitId = currentSystem[FIELD_UNIT + w];
    if (!wUnitId) return result;

    const pikeSet = typeSectionAutoCheckCluster(w, C_pike, currentSystem);
    const axeSet  = typeSectionAutoCheckCluster(w, C_axe,  currentSystem);

    // Объединяем кластеры
    result = new Set([...pikeSet, ...axeSet]);

    return result;
}

function typeSectionAutoCheckCluster(w, sort, currentSystem) {
    let result = new Set();
    let section;

    const wUnitId = currentSystem[FIELD_UNIT + w];
    if (!wUnitId) return result;

    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2

    if (sort === C_axe) {
        section = getStarAxe(w);
    }
    if (sort === C_pike) {
        section = getStarPike(w);
    }

    result = processRay(wUnitId, section, currentSystem, ownSide, false);

    return result;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function typeAxeAutoCheckCluster(w, currentSystem) {
    let result = new Set();

    const wUnitId = currentSystem[FIELD_UNIT + w];
    if (!wUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + wUnitId];

    let beam = getBeamAxe(p, w);
    if (!p || !beam) return result;
    result = processRay(wUnitId, beam, currentSystem, ownSide, false);

    return result;
}

function typePikeAutoCheckCluster(w, currentSystem) {
    let result = new Set();

    const wUnitId = currentSystem[FIELD_UNIT + w];
    if (!wUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + wUnitId];

    let beam = getBeamPike(p, w);
    if (!p || !beam) return result;
    result = processRay(wUnitId, beam, currentSystem, ownSide, false);

    return result;
}

function typeArrowAutoCheckCluster(w, currentSystem) {
    let result = new Set();

    const wUnitId = currentSystem[FIELD_UNIT + w];
    if (!wUnitId) return result;
    const ownSide = currentSystem[UNIT_SIDE + wUnitId]; // 1 или 2
    const p = currentSystem[UNIT_PREV + wUnitId];

    const stepZero = (
        (ownSide === 1 && p === 1 && !lSet.has(w)) ||
        (ownSide === 2 && p === 2 && !dSet.has(w))
    );

    if (stepZero) {
        let firstMove = processMoveList(wUnitId, getFirstMoveArrow(p, w), currentSystem, ownSide, false);
        let firstCapture = processCaptureList(wUnitId, getFirstCaptureArrow(p, w), currentSystem, ownSide, false);

        result = new Set([...firstMove, ...firstCapture]);
    } else {
        let usualMove = processMoveList(wUnitId, getMoveArrow(p, w), currentSystem, ownSide, false);
        let usualCapture = processCaptureList(wUnitId, getCaptureArrow(p, w), currentSystem, ownSide, false);

        result = new Set([...usualMove, ...usualCapture]);
    }

    return result;
}

/////////////////////////// ВСПОМОГАТЕЛЬНЫЕ process //////////////////////////////////////////////////////////////////////////////////////////////////////////
function processRay(vUnitId, ray, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = ray.length;

    while (i < len) {
        const field = ray[i];

        if (field === 0) { // Начало луча — сбрасываем, переходим дальше
            i++;
            continue;
        }

        // Поле не ноль
        const unitId = currentSystem[FIELD_UNIT + field];

        if (unitId === 0) { // Пустое поле — добавляем и идём дальше
            if (testAuto) {
                if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                    result.add(field);
                }
            } else {
                result.add(field);
            }
            i++;
        } else {
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Своя фигура — НЕ добавляем, ПРОСТО СРАЗУ пролистываем до следующего 0 или конца
                i++;
                while (i < len && ray[i] !== 0) i++;
            } else { // Чужая фигура — добавляем, затем пролистываем до следующего 0 или конца
                if (testAuto) {
                    if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                        result.add(field);
                    }
                } else {
                    result.add(field);
                }
                i++;
                while (i < len && ray[i] !== 0) i++;
            }
        }
    }

    return result;
}

function processList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из currentSystem
        
        if (unitId === 0) { // Пустое поле — добавляем и идём дальше
            if (testAuto) {
                if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                    result.add(field);
                }
            }
            else {
                result.add(field);
            }
            i++;
        } else {
            
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Своя фигура — НЕ добавляем
                i++;
            } else { // Чужая фигура — добавляем
                if (testAuto) {
                    if (!typeTestAutoCheck(vUnitId, field, currentSystem)) { 
                        result.add(field);
                    }
                }
                else {
                    result.add(field);
                }
                i++;
            }
        }
        
    }

    return result;
}

function processMoveList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из system

        if (unitId === 0) { // Пустое поле — добавляем и идём дальше
            if (testAuto) {
                if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                    result.add(field);
                }
            } else {
                result.add(field);
            }
        }
        i++;
    }

    return result;
}

function processCaptureList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из system

        if (unitId !== 0) {
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide !== originalSide) { // Чужая фигура — добавляем
                if (testAuto) {
                    if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                        result.add(field);
                    }
                } else {
                    result.add(field);
                }
            }
        }
        i++;
    }

    return result;
}

function processSupportList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из system

        if (unitId !== 0) {
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Чужая фигура — добавляем
                if (testAuto) {
                    if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                        result.add(field);
                    }
                } else {
                    result.add(field);
                }
            }
        }
        i++;
    }

    return result;
}

function processControlList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из system
        const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

        if (unitId === 0 || unitSide !== originalSide) { // Если Пусто или Чужая фигура — добавляем
            if (testAuto) {
                if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                    result.add(field);
                }
            } else {
                result.add(field);
            }
        }
        
        i++;
    }

    return result;
}

function processCastlingList(vUnitId, list, currentSystem, originalSide, testAuto) {
    const result = new Set();
    let i = 0;
    const len = list.length;
    
    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из currentSystem

        if (unitId !== 0) {
            const unitSide     = currentSystem[UNIT_SIDE + unitId]; // 1 или 2
            const unitSort     = currentSystem[UNIT_SORT + unitId];
            const unitCastling = currentSystem[UNIT_CASTLING + unitId];

            if (unitSide === originalSide && (unitSort === C_sword || unitSort === C_pike || unitSort === C_axe) && unitCastling === 1) { // Свой Король
                if (testAuto) {
                    if (!typeTestAutoCheck(vUnitId, field, currentSystem)) {
                        result.add(field);
                    }
                }
                else {
                    result.add(field);
                }
            }
        }
        i++;
    }
    
    return result;
} 

/////////////////////////// ВСПОМОГАТЕЛЬНЫЕ support //////////////////////////////////////////////////////////////////////////////////////////////////////////
function supportRay(vUnitId, ray, currentSystem, originalSide) {
    const result = new Set();
    let i = 0;
    const len = ray.length;

    while (i < len) {
        const field = ray[i];

        if (field === 0) { // Начало луча — сбрасываем, переходим дальше
            i++;
            continue;
        }

        // Поле не ноль
        const unitId = currentSystem[FIELD_UNIT + field];

        if (unitId === 0) { // Пустое поле — НЕ добавляем, а идём дальше
            i++;
        } else {
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Своя фигура — добавляем, и пролистываем до следующего 0 или конца
                result.add(field);
                i++;
                while (i < len && ray[i] !== 0) i++;
            } else { // 2b) Чужая фигура — НЕ добавляем, а пролистываем до следующего 0 или конца
                i++;
                while (i < len && ray[i] !== 0) i++;
            }
        }
    }

    return result;
}

function supportList(vUnitId, list, currentSystem, originalSide) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из currentSystem
        
        if (unitId === 0) { // Пустое поле — НЕ добавляем, а просто идём дальше
            i++;
        } else {
            
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Своя фигура — добавляем и идём дальше
                result.add(field);
                i++;
            } else { // Чужая фигура —  НЕ добавляем, а просто идём дальше
                i++;
            }
        }
        
    }

    return result;
}

function supportCaptureList(vUnitId, list, currentSystem, originalSide) {
    const result = new Set();
    let i = 0;
    const len = list.length;

    while (i < len) {
        const field = list[i];
        const unitId = currentSystem[FIELD_UNIT + field]; // Чтение из system

        if (unitId !== 0) {
            const unitSide = currentSystem[UNIT_SIDE + unitId]; // 1 или 2

            if (unitSide === originalSide) { // Своя фигура — добавляем
                result.add(field);
            }
        }
        i++;
    }

    return result;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////